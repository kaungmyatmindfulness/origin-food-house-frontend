/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * This file exports the `Subscription` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from '@prisma/client/runtime/client';
import type * as $Enums from '../enums';
import type * as Prisma from '../internal/prismaNamespace';

/**
 * Model Subscription
 *
 */
export type SubscriptionModel =
  runtime.Types.Result.DefaultSelection<Prisma.$SubscriptionPayload>;

export type AggregateSubscription = {
  _count: SubscriptionCountAggregateOutputType | null;
  _min: SubscriptionMinAggregateOutputType | null;
  _max: SubscriptionMaxAggregateOutputType | null;
};

export type SubscriptionMinAggregateOutputType = {
  id: string | null;
  storeId: string | null;
  tier: $Enums.SubscriptionTier | null;
  status: $Enums.SubscriptionStatus | null;
  isTrialUsed: boolean | null;
  trialStartedAt: Date | null;
  trialEndsAt: Date | null;
  currentPeriodStart: Date | null;
  currentPeriodEnd: Date | null;
  billingCycle: $Enums.BillingCycle | null;
  cancelledAt: Date | null;
  cancellationReason: string | null;
  overriddenBy: string | null;
  overrideReason: string | null;
  overriddenAt: Date | null;
  createdAt: Date | null;
  updatedAt: Date | null;
};

export type SubscriptionMaxAggregateOutputType = {
  id: string | null;
  storeId: string | null;
  tier: $Enums.SubscriptionTier | null;
  status: $Enums.SubscriptionStatus | null;
  isTrialUsed: boolean | null;
  trialStartedAt: Date | null;
  trialEndsAt: Date | null;
  currentPeriodStart: Date | null;
  currentPeriodEnd: Date | null;
  billingCycle: $Enums.BillingCycle | null;
  cancelledAt: Date | null;
  cancellationReason: string | null;
  overriddenBy: string | null;
  overrideReason: string | null;
  overriddenAt: Date | null;
  createdAt: Date | null;
  updatedAt: Date | null;
};

export type SubscriptionCountAggregateOutputType = {
  id: number;
  storeId: number;
  tier: number;
  status: number;
  isTrialUsed: number;
  trialStartedAt: number;
  trialEndsAt: number;
  currentPeriodStart: number;
  currentPeriodEnd: number;
  billingCycle: number;
  cancelledAt: number;
  cancellationReason: number;
  overriddenBy: number;
  overrideReason: number;
  overriddenAt: number;
  createdAt: number;
  updatedAt: number;
  _all: number;
};

export type SubscriptionMinAggregateInputType = {
  id?: true;
  storeId?: true;
  tier?: true;
  status?: true;
  isTrialUsed?: true;
  trialStartedAt?: true;
  trialEndsAt?: true;
  currentPeriodStart?: true;
  currentPeriodEnd?: true;
  billingCycle?: true;
  cancelledAt?: true;
  cancellationReason?: true;
  overriddenBy?: true;
  overrideReason?: true;
  overriddenAt?: true;
  createdAt?: true;
  updatedAt?: true;
};

export type SubscriptionMaxAggregateInputType = {
  id?: true;
  storeId?: true;
  tier?: true;
  status?: true;
  isTrialUsed?: true;
  trialStartedAt?: true;
  trialEndsAt?: true;
  currentPeriodStart?: true;
  currentPeriodEnd?: true;
  billingCycle?: true;
  cancelledAt?: true;
  cancellationReason?: true;
  overriddenBy?: true;
  overrideReason?: true;
  overriddenAt?: true;
  createdAt?: true;
  updatedAt?: true;
};

export type SubscriptionCountAggregateInputType = {
  id?: true;
  storeId?: true;
  tier?: true;
  status?: true;
  isTrialUsed?: true;
  trialStartedAt?: true;
  trialEndsAt?: true;
  currentPeriodStart?: true;
  currentPeriodEnd?: true;
  billingCycle?: true;
  cancelledAt?: true;
  cancellationReason?: true;
  overriddenBy?: true;
  overrideReason?: true;
  overriddenAt?: true;
  createdAt?: true;
  updatedAt?: true;
  _all?: true;
};

export type SubscriptionAggregateArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Filter which Subscription to aggregate.
   */
  where?: Prisma.SubscriptionWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of Subscriptions to fetch.
   */
  orderBy?:
    | Prisma.SubscriptionOrderByWithRelationInput
    | Prisma.SubscriptionOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the start position
   */
  cursor?: Prisma.SubscriptionWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` Subscriptions from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` Subscriptions.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Count returned Subscriptions
   **/
  _count?: true | SubscriptionCountAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to find the minimum value
   **/
  _min?: SubscriptionMinAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to find the maximum value
   **/
  _max?: SubscriptionMaxAggregateInputType;
};

export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> =
  {
    [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : Prisma.GetScalarType<T[P], AggregateSubscription[P]>
      : Prisma.GetScalarType<T[P], AggregateSubscription[P]>;
  };

export type SubscriptionGroupByArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.SubscriptionWhereInput;
  orderBy?:
    | Prisma.SubscriptionOrderByWithAggregationInput
    | Prisma.SubscriptionOrderByWithAggregationInput[];
  by: Prisma.SubscriptionScalarFieldEnum[] | Prisma.SubscriptionScalarFieldEnum;
  having?: Prisma.SubscriptionScalarWhereWithAggregatesInput;
  take?: number;
  skip?: number;
  _count?: SubscriptionCountAggregateInputType | true;
  _min?: SubscriptionMinAggregateInputType;
  _max?: SubscriptionMaxAggregateInputType;
};

export type SubscriptionGroupByOutputType = {
  id: string;
  storeId: string;
  tier: $Enums.SubscriptionTier;
  status: $Enums.SubscriptionStatus;
  isTrialUsed: boolean;
  trialStartedAt: Date | null;
  trialEndsAt: Date | null;
  currentPeriodStart: Date | null;
  currentPeriodEnd: Date | null;
  billingCycle: $Enums.BillingCycle;
  cancelledAt: Date | null;
  cancellationReason: string | null;
  overriddenBy: string | null;
  overrideReason: string | null;
  overriddenAt: Date | null;
  createdAt: Date;
  updatedAt: Date;
  _count: SubscriptionCountAggregateOutputType | null;
  _min: SubscriptionMinAggregateOutputType | null;
  _max: SubscriptionMaxAggregateOutputType | null;
};

type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> =
  Prisma.PrismaPromise<
    Array<
      Prisma.PickEnumerable<SubscriptionGroupByOutputType, T['by']> & {
        [P in keyof T & keyof SubscriptionGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], SubscriptionGroupByOutputType[P]>;
      }
    >
  >;

export type SubscriptionWhereInput = {
  AND?: Prisma.SubscriptionWhereInput | Prisma.SubscriptionWhereInput[];
  OR?: Prisma.SubscriptionWhereInput[];
  NOT?: Prisma.SubscriptionWhereInput | Prisma.SubscriptionWhereInput[];
  id?: Prisma.StringFilter<'Subscription'> | string;
  storeId?: Prisma.StringFilter<'Subscription'> | string;
  tier?:
    | Prisma.EnumSubscriptionTierFilter<'Subscription'>
    | $Enums.SubscriptionTier;
  status?:
    | Prisma.EnumSubscriptionStatusFilter<'Subscription'>
    | $Enums.SubscriptionStatus;
  isTrialUsed?: Prisma.BoolFilter<'Subscription'> | boolean;
  trialStartedAt?:
    | Prisma.DateTimeNullableFilter<'Subscription'>
    | Date
    | string
    | null;
  trialEndsAt?:
    | Prisma.DateTimeNullableFilter<'Subscription'>
    | Date
    | string
    | null;
  currentPeriodStart?:
    | Prisma.DateTimeNullableFilter<'Subscription'>
    | Date
    | string
    | null;
  currentPeriodEnd?:
    | Prisma.DateTimeNullableFilter<'Subscription'>
    | Date
    | string
    | null;
  billingCycle?:
    | Prisma.EnumBillingCycleFilter<'Subscription'>
    | $Enums.BillingCycle;
  cancelledAt?:
    | Prisma.DateTimeNullableFilter<'Subscription'>
    | Date
    | string
    | null;
  cancellationReason?:
    | Prisma.StringNullableFilter<'Subscription'>
    | string
    | null;
  overriddenBy?: Prisma.StringNullableFilter<'Subscription'> | string | null;
  overrideReason?: Prisma.StringNullableFilter<'Subscription'> | string | null;
  overriddenAt?:
    | Prisma.DateTimeNullableFilter<'Subscription'>
    | Date
    | string
    | null;
  createdAt?: Prisma.DateTimeFilter<'Subscription'> | Date | string;
  updatedAt?: Prisma.DateTimeFilter<'Subscription'> | Date | string;
  store?: Prisma.XOR<Prisma.StoreScalarRelationFilter, Prisma.StoreWhereInput>;
  paymentRequests?: Prisma.PaymentRequestListRelationFilter;
  paymentTransactions?: Prisma.PaymentTransactionListRelationFilter;
  refundRequests?: Prisma.RefundRequestListRelationFilter;
  overriddenByAdmin?: Prisma.XOR<
    Prisma.AdminUserNullableScalarRelationFilter,
    Prisma.AdminUserWhereInput
  > | null;
};

export type SubscriptionOrderByWithRelationInput = {
  id?: Prisma.SortOrder;
  storeId?: Prisma.SortOrder;
  tier?: Prisma.SortOrder;
  status?: Prisma.SortOrder;
  isTrialUsed?: Prisma.SortOrder;
  trialStartedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
  trialEndsAt?: Prisma.SortOrderInput | Prisma.SortOrder;
  currentPeriodStart?: Prisma.SortOrderInput | Prisma.SortOrder;
  currentPeriodEnd?: Prisma.SortOrderInput | Prisma.SortOrder;
  billingCycle?: Prisma.SortOrder;
  cancelledAt?: Prisma.SortOrderInput | Prisma.SortOrder;
  cancellationReason?: Prisma.SortOrderInput | Prisma.SortOrder;
  overriddenBy?: Prisma.SortOrderInput | Prisma.SortOrder;
  overrideReason?: Prisma.SortOrderInput | Prisma.SortOrder;
  overriddenAt?: Prisma.SortOrderInput | Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  updatedAt?: Prisma.SortOrder;
  store?: Prisma.StoreOrderByWithRelationInput;
  paymentRequests?: Prisma.PaymentRequestOrderByRelationAggregateInput;
  paymentTransactions?: Prisma.PaymentTransactionOrderByRelationAggregateInput;
  refundRequests?: Prisma.RefundRequestOrderByRelationAggregateInput;
  overriddenByAdmin?: Prisma.AdminUserOrderByWithRelationInput;
};

export type SubscriptionWhereUniqueInput = Prisma.AtLeast<
  {
    id?: string;
    storeId?: string;
    AND?: Prisma.SubscriptionWhereInput | Prisma.SubscriptionWhereInput[];
    OR?: Prisma.SubscriptionWhereInput[];
    NOT?: Prisma.SubscriptionWhereInput | Prisma.SubscriptionWhereInput[];
    tier?:
      | Prisma.EnumSubscriptionTierFilter<'Subscription'>
      | $Enums.SubscriptionTier;
    status?:
      | Prisma.EnumSubscriptionStatusFilter<'Subscription'>
      | $Enums.SubscriptionStatus;
    isTrialUsed?: Prisma.BoolFilter<'Subscription'> | boolean;
    trialStartedAt?:
      | Prisma.DateTimeNullableFilter<'Subscription'>
      | Date
      | string
      | null;
    trialEndsAt?:
      | Prisma.DateTimeNullableFilter<'Subscription'>
      | Date
      | string
      | null;
    currentPeriodStart?:
      | Prisma.DateTimeNullableFilter<'Subscription'>
      | Date
      | string
      | null;
    currentPeriodEnd?:
      | Prisma.DateTimeNullableFilter<'Subscription'>
      | Date
      | string
      | null;
    billingCycle?:
      | Prisma.EnumBillingCycleFilter<'Subscription'>
      | $Enums.BillingCycle;
    cancelledAt?:
      | Prisma.DateTimeNullableFilter<'Subscription'>
      | Date
      | string
      | null;
    cancellationReason?:
      | Prisma.StringNullableFilter<'Subscription'>
      | string
      | null;
    overriddenBy?: Prisma.StringNullableFilter<'Subscription'> | string | null;
    overrideReason?:
      | Prisma.StringNullableFilter<'Subscription'>
      | string
      | null;
    overriddenAt?:
      | Prisma.DateTimeNullableFilter<'Subscription'>
      | Date
      | string
      | null;
    createdAt?: Prisma.DateTimeFilter<'Subscription'> | Date | string;
    updatedAt?: Prisma.DateTimeFilter<'Subscription'> | Date | string;
    store?: Prisma.XOR<
      Prisma.StoreScalarRelationFilter,
      Prisma.StoreWhereInput
    >;
    paymentRequests?: Prisma.PaymentRequestListRelationFilter;
    paymentTransactions?: Prisma.PaymentTransactionListRelationFilter;
    refundRequests?: Prisma.RefundRequestListRelationFilter;
    overriddenByAdmin?: Prisma.XOR<
      Prisma.AdminUserNullableScalarRelationFilter,
      Prisma.AdminUserWhereInput
    > | null;
  },
  'id' | 'storeId'
>;

export type SubscriptionOrderByWithAggregationInput = {
  id?: Prisma.SortOrder;
  storeId?: Prisma.SortOrder;
  tier?: Prisma.SortOrder;
  status?: Prisma.SortOrder;
  isTrialUsed?: Prisma.SortOrder;
  trialStartedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
  trialEndsAt?: Prisma.SortOrderInput | Prisma.SortOrder;
  currentPeriodStart?: Prisma.SortOrderInput | Prisma.SortOrder;
  currentPeriodEnd?: Prisma.SortOrderInput | Prisma.SortOrder;
  billingCycle?: Prisma.SortOrder;
  cancelledAt?: Prisma.SortOrderInput | Prisma.SortOrder;
  cancellationReason?: Prisma.SortOrderInput | Prisma.SortOrder;
  overriddenBy?: Prisma.SortOrderInput | Prisma.SortOrder;
  overrideReason?: Prisma.SortOrderInput | Prisma.SortOrder;
  overriddenAt?: Prisma.SortOrderInput | Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  updatedAt?: Prisma.SortOrder;
  _count?: Prisma.SubscriptionCountOrderByAggregateInput;
  _max?: Prisma.SubscriptionMaxOrderByAggregateInput;
  _min?: Prisma.SubscriptionMinOrderByAggregateInput;
};

export type SubscriptionScalarWhereWithAggregatesInput = {
  AND?:
    | Prisma.SubscriptionScalarWhereWithAggregatesInput
    | Prisma.SubscriptionScalarWhereWithAggregatesInput[];
  OR?: Prisma.SubscriptionScalarWhereWithAggregatesInput[];
  NOT?:
    | Prisma.SubscriptionScalarWhereWithAggregatesInput
    | Prisma.SubscriptionScalarWhereWithAggregatesInput[];
  id?: Prisma.StringWithAggregatesFilter<'Subscription'> | string;
  storeId?: Prisma.StringWithAggregatesFilter<'Subscription'> | string;
  tier?:
    | Prisma.EnumSubscriptionTierWithAggregatesFilter<'Subscription'>
    | $Enums.SubscriptionTier;
  status?:
    | Prisma.EnumSubscriptionStatusWithAggregatesFilter<'Subscription'>
    | $Enums.SubscriptionStatus;
  isTrialUsed?: Prisma.BoolWithAggregatesFilter<'Subscription'> | boolean;
  trialStartedAt?:
    | Prisma.DateTimeNullableWithAggregatesFilter<'Subscription'>
    | Date
    | string
    | null;
  trialEndsAt?:
    | Prisma.DateTimeNullableWithAggregatesFilter<'Subscription'>
    | Date
    | string
    | null;
  currentPeriodStart?:
    | Prisma.DateTimeNullableWithAggregatesFilter<'Subscription'>
    | Date
    | string
    | null;
  currentPeriodEnd?:
    | Prisma.DateTimeNullableWithAggregatesFilter<'Subscription'>
    | Date
    | string
    | null;
  billingCycle?:
    | Prisma.EnumBillingCycleWithAggregatesFilter<'Subscription'>
    | $Enums.BillingCycle;
  cancelledAt?:
    | Prisma.DateTimeNullableWithAggregatesFilter<'Subscription'>
    | Date
    | string
    | null;
  cancellationReason?:
    | Prisma.StringNullableWithAggregatesFilter<'Subscription'>
    | string
    | null;
  overriddenBy?:
    | Prisma.StringNullableWithAggregatesFilter<'Subscription'>
    | string
    | null;
  overrideReason?:
    | Prisma.StringNullableWithAggregatesFilter<'Subscription'>
    | string
    | null;
  overriddenAt?:
    | Prisma.DateTimeNullableWithAggregatesFilter<'Subscription'>
    | Date
    | string
    | null;
  createdAt?:
    | Prisma.DateTimeWithAggregatesFilter<'Subscription'>
    | Date
    | string;
  updatedAt?:
    | Prisma.DateTimeWithAggregatesFilter<'Subscription'>
    | Date
    | string;
};

export type SubscriptionCreateInput = {
  id?: string;
  tier?: $Enums.SubscriptionTier;
  status?: $Enums.SubscriptionStatus;
  isTrialUsed?: boolean;
  trialStartedAt?: Date | string | null;
  trialEndsAt?: Date | string | null;
  currentPeriodStart?: Date | string | null;
  currentPeriodEnd?: Date | string | null;
  billingCycle?: $Enums.BillingCycle;
  cancelledAt?: Date | string | null;
  cancellationReason?: string | null;
  overrideReason?: string | null;
  overriddenAt?: Date | string | null;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  store: Prisma.StoreCreateNestedOneWithoutSubscriptionInput;
  paymentRequests?: Prisma.PaymentRequestCreateNestedManyWithoutSubscriptionInput;
  paymentTransactions?: Prisma.PaymentTransactionCreateNestedManyWithoutSubscriptionInput;
  refundRequests?: Prisma.RefundRequestCreateNestedManyWithoutSubscriptionInput;
  overriddenByAdmin?: Prisma.AdminUserCreateNestedOneWithoutOverriddenSubscriptionsInput;
};

export type SubscriptionUncheckedCreateInput = {
  id?: string;
  storeId: string;
  tier?: $Enums.SubscriptionTier;
  status?: $Enums.SubscriptionStatus;
  isTrialUsed?: boolean;
  trialStartedAt?: Date | string | null;
  trialEndsAt?: Date | string | null;
  currentPeriodStart?: Date | string | null;
  currentPeriodEnd?: Date | string | null;
  billingCycle?: $Enums.BillingCycle;
  cancelledAt?: Date | string | null;
  cancellationReason?: string | null;
  overriddenBy?: string | null;
  overrideReason?: string | null;
  overriddenAt?: Date | string | null;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  paymentRequests?: Prisma.PaymentRequestUncheckedCreateNestedManyWithoutSubscriptionInput;
  paymentTransactions?: Prisma.PaymentTransactionUncheckedCreateNestedManyWithoutSubscriptionInput;
  refundRequests?: Prisma.RefundRequestUncheckedCreateNestedManyWithoutSubscriptionInput;
};

export type SubscriptionUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  tier?:
    | Prisma.EnumSubscriptionTierFieldUpdateOperationsInput
    | $Enums.SubscriptionTier;
  status?:
    | Prisma.EnumSubscriptionStatusFieldUpdateOperationsInput
    | $Enums.SubscriptionStatus;
  isTrialUsed?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  trialStartedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  trialEndsAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodStart?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodEnd?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  billingCycle?:
    | Prisma.EnumBillingCycleFieldUpdateOperationsInput
    | $Enums.BillingCycle;
  cancelledAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  cancellationReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overrideReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overriddenAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  store?: Prisma.StoreUpdateOneRequiredWithoutSubscriptionNestedInput;
  paymentRequests?: Prisma.PaymentRequestUpdateManyWithoutSubscriptionNestedInput;
  paymentTransactions?: Prisma.PaymentTransactionUpdateManyWithoutSubscriptionNestedInput;
  refundRequests?: Prisma.RefundRequestUpdateManyWithoutSubscriptionNestedInput;
  overriddenByAdmin?: Prisma.AdminUserUpdateOneWithoutOverriddenSubscriptionsNestedInput;
};

export type SubscriptionUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  storeId?: Prisma.StringFieldUpdateOperationsInput | string;
  tier?:
    | Prisma.EnumSubscriptionTierFieldUpdateOperationsInput
    | $Enums.SubscriptionTier;
  status?:
    | Prisma.EnumSubscriptionStatusFieldUpdateOperationsInput
    | $Enums.SubscriptionStatus;
  isTrialUsed?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  trialStartedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  trialEndsAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodStart?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodEnd?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  billingCycle?:
    | Prisma.EnumBillingCycleFieldUpdateOperationsInput
    | $Enums.BillingCycle;
  cancelledAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  cancellationReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overriddenBy?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overrideReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overriddenAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  paymentRequests?: Prisma.PaymentRequestUncheckedUpdateManyWithoutSubscriptionNestedInput;
  paymentTransactions?: Prisma.PaymentTransactionUncheckedUpdateManyWithoutSubscriptionNestedInput;
  refundRequests?: Prisma.RefundRequestUncheckedUpdateManyWithoutSubscriptionNestedInput;
};

export type SubscriptionCreateManyInput = {
  id?: string;
  storeId: string;
  tier?: $Enums.SubscriptionTier;
  status?: $Enums.SubscriptionStatus;
  isTrialUsed?: boolean;
  trialStartedAt?: Date | string | null;
  trialEndsAt?: Date | string | null;
  currentPeriodStart?: Date | string | null;
  currentPeriodEnd?: Date | string | null;
  billingCycle?: $Enums.BillingCycle;
  cancelledAt?: Date | string | null;
  cancellationReason?: string | null;
  overriddenBy?: string | null;
  overrideReason?: string | null;
  overriddenAt?: Date | string | null;
  createdAt?: Date | string;
  updatedAt?: Date | string;
};

export type SubscriptionUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  tier?:
    | Prisma.EnumSubscriptionTierFieldUpdateOperationsInput
    | $Enums.SubscriptionTier;
  status?:
    | Prisma.EnumSubscriptionStatusFieldUpdateOperationsInput
    | $Enums.SubscriptionStatus;
  isTrialUsed?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  trialStartedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  trialEndsAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodStart?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodEnd?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  billingCycle?:
    | Prisma.EnumBillingCycleFieldUpdateOperationsInput
    | $Enums.BillingCycle;
  cancelledAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  cancellationReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overrideReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overriddenAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type SubscriptionUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  storeId?: Prisma.StringFieldUpdateOperationsInput | string;
  tier?:
    | Prisma.EnumSubscriptionTierFieldUpdateOperationsInput
    | $Enums.SubscriptionTier;
  status?:
    | Prisma.EnumSubscriptionStatusFieldUpdateOperationsInput
    | $Enums.SubscriptionStatus;
  isTrialUsed?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  trialStartedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  trialEndsAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodStart?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodEnd?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  billingCycle?:
    | Prisma.EnumBillingCycleFieldUpdateOperationsInput
    | $Enums.BillingCycle;
  cancelledAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  cancellationReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overriddenBy?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overrideReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overriddenAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type SubscriptionNullableScalarRelationFilter = {
  is?: Prisma.SubscriptionWhereInput | null;
  isNot?: Prisma.SubscriptionWhereInput | null;
};

export type SubscriptionCountOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  storeId?: Prisma.SortOrder;
  tier?: Prisma.SortOrder;
  status?: Prisma.SortOrder;
  isTrialUsed?: Prisma.SortOrder;
  trialStartedAt?: Prisma.SortOrder;
  trialEndsAt?: Prisma.SortOrder;
  currentPeriodStart?: Prisma.SortOrder;
  currentPeriodEnd?: Prisma.SortOrder;
  billingCycle?: Prisma.SortOrder;
  cancelledAt?: Prisma.SortOrder;
  cancellationReason?: Prisma.SortOrder;
  overriddenBy?: Prisma.SortOrder;
  overrideReason?: Prisma.SortOrder;
  overriddenAt?: Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  updatedAt?: Prisma.SortOrder;
};

export type SubscriptionMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  storeId?: Prisma.SortOrder;
  tier?: Prisma.SortOrder;
  status?: Prisma.SortOrder;
  isTrialUsed?: Prisma.SortOrder;
  trialStartedAt?: Prisma.SortOrder;
  trialEndsAt?: Prisma.SortOrder;
  currentPeriodStart?: Prisma.SortOrder;
  currentPeriodEnd?: Prisma.SortOrder;
  billingCycle?: Prisma.SortOrder;
  cancelledAt?: Prisma.SortOrder;
  cancellationReason?: Prisma.SortOrder;
  overriddenBy?: Prisma.SortOrder;
  overrideReason?: Prisma.SortOrder;
  overriddenAt?: Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  updatedAt?: Prisma.SortOrder;
};

export type SubscriptionMinOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  storeId?: Prisma.SortOrder;
  tier?: Prisma.SortOrder;
  status?: Prisma.SortOrder;
  isTrialUsed?: Prisma.SortOrder;
  trialStartedAt?: Prisma.SortOrder;
  trialEndsAt?: Prisma.SortOrder;
  currentPeriodStart?: Prisma.SortOrder;
  currentPeriodEnd?: Prisma.SortOrder;
  billingCycle?: Prisma.SortOrder;
  cancelledAt?: Prisma.SortOrder;
  cancellationReason?: Prisma.SortOrder;
  overriddenBy?: Prisma.SortOrder;
  overrideReason?: Prisma.SortOrder;
  overriddenAt?: Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  updatedAt?: Prisma.SortOrder;
};

export type SubscriptionScalarRelationFilter = {
  is?: Prisma.SubscriptionWhereInput;
  isNot?: Prisma.SubscriptionWhereInput;
};

export type SubscriptionListRelationFilter = {
  every?: Prisma.SubscriptionWhereInput;
  some?: Prisma.SubscriptionWhereInput;
  none?: Prisma.SubscriptionWhereInput;
};

export type SubscriptionOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder;
};

export type SubscriptionCreateNestedOneWithoutStoreInput = {
  create?: Prisma.XOR<
    Prisma.SubscriptionCreateWithoutStoreInput,
    Prisma.SubscriptionUncheckedCreateWithoutStoreInput
  >;
  connectOrCreate?: Prisma.SubscriptionCreateOrConnectWithoutStoreInput;
  connect?: Prisma.SubscriptionWhereUniqueInput;
};

export type SubscriptionUncheckedCreateNestedOneWithoutStoreInput = {
  create?: Prisma.XOR<
    Prisma.SubscriptionCreateWithoutStoreInput,
    Prisma.SubscriptionUncheckedCreateWithoutStoreInput
  >;
  connectOrCreate?: Prisma.SubscriptionCreateOrConnectWithoutStoreInput;
  connect?: Prisma.SubscriptionWhereUniqueInput;
};

export type SubscriptionUpdateOneWithoutStoreNestedInput = {
  create?: Prisma.XOR<
    Prisma.SubscriptionCreateWithoutStoreInput,
    Prisma.SubscriptionUncheckedCreateWithoutStoreInput
  >;
  connectOrCreate?: Prisma.SubscriptionCreateOrConnectWithoutStoreInput;
  upsert?: Prisma.SubscriptionUpsertWithoutStoreInput;
  disconnect?: Prisma.SubscriptionWhereInput | boolean;
  delete?: Prisma.SubscriptionWhereInput | boolean;
  connect?: Prisma.SubscriptionWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.SubscriptionUpdateToOneWithWhereWithoutStoreInput,
      Prisma.SubscriptionUpdateWithoutStoreInput
    >,
    Prisma.SubscriptionUncheckedUpdateWithoutStoreInput
  >;
};

export type SubscriptionUncheckedUpdateOneWithoutStoreNestedInput = {
  create?: Prisma.XOR<
    Prisma.SubscriptionCreateWithoutStoreInput,
    Prisma.SubscriptionUncheckedCreateWithoutStoreInput
  >;
  connectOrCreate?: Prisma.SubscriptionCreateOrConnectWithoutStoreInput;
  upsert?: Prisma.SubscriptionUpsertWithoutStoreInput;
  disconnect?: Prisma.SubscriptionWhereInput | boolean;
  delete?: Prisma.SubscriptionWhereInput | boolean;
  connect?: Prisma.SubscriptionWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.SubscriptionUpdateToOneWithWhereWithoutStoreInput,
      Prisma.SubscriptionUpdateWithoutStoreInput
    >,
    Prisma.SubscriptionUncheckedUpdateWithoutStoreInput
  >;
};

export type EnumSubscriptionTierFieldUpdateOperationsInput = {
  set?: $Enums.SubscriptionTier;
};

export type SubscriptionCreateNestedOneWithoutPaymentRequestsInput = {
  create?: Prisma.XOR<
    Prisma.SubscriptionCreateWithoutPaymentRequestsInput,
    Prisma.SubscriptionUncheckedCreateWithoutPaymentRequestsInput
  >;
  connectOrCreate?: Prisma.SubscriptionCreateOrConnectWithoutPaymentRequestsInput;
  connect?: Prisma.SubscriptionWhereUniqueInput;
};

export type SubscriptionUpdateOneRequiredWithoutPaymentRequestsNestedInput = {
  create?: Prisma.XOR<
    Prisma.SubscriptionCreateWithoutPaymentRequestsInput,
    Prisma.SubscriptionUncheckedCreateWithoutPaymentRequestsInput
  >;
  connectOrCreate?: Prisma.SubscriptionCreateOrConnectWithoutPaymentRequestsInput;
  upsert?: Prisma.SubscriptionUpsertWithoutPaymentRequestsInput;
  connect?: Prisma.SubscriptionWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.SubscriptionUpdateToOneWithWhereWithoutPaymentRequestsInput,
      Prisma.SubscriptionUpdateWithoutPaymentRequestsInput
    >,
    Prisma.SubscriptionUncheckedUpdateWithoutPaymentRequestsInput
  >;
};

export type SubscriptionCreateNestedOneWithoutPaymentTransactionsInput = {
  create?: Prisma.XOR<
    Prisma.SubscriptionCreateWithoutPaymentTransactionsInput,
    Prisma.SubscriptionUncheckedCreateWithoutPaymentTransactionsInput
  >;
  connectOrCreate?: Prisma.SubscriptionCreateOrConnectWithoutPaymentTransactionsInput;
  connect?: Prisma.SubscriptionWhereUniqueInput;
};

export type SubscriptionUpdateOneRequiredWithoutPaymentTransactionsNestedInput =
  {
    create?: Prisma.XOR<
      Prisma.SubscriptionCreateWithoutPaymentTransactionsInput,
      Prisma.SubscriptionUncheckedCreateWithoutPaymentTransactionsInput
    >;
    connectOrCreate?: Prisma.SubscriptionCreateOrConnectWithoutPaymentTransactionsInput;
    upsert?: Prisma.SubscriptionUpsertWithoutPaymentTransactionsInput;
    connect?: Prisma.SubscriptionWhereUniqueInput;
    update?: Prisma.XOR<
      Prisma.XOR<
        Prisma.SubscriptionUpdateToOneWithWhereWithoutPaymentTransactionsInput,
        Prisma.SubscriptionUpdateWithoutPaymentTransactionsInput
      >,
      Prisma.SubscriptionUncheckedUpdateWithoutPaymentTransactionsInput
    >;
  };

export type SubscriptionCreateNestedOneWithoutRefundRequestsInput = {
  create?: Prisma.XOR<
    Prisma.SubscriptionCreateWithoutRefundRequestsInput,
    Prisma.SubscriptionUncheckedCreateWithoutRefundRequestsInput
  >;
  connectOrCreate?: Prisma.SubscriptionCreateOrConnectWithoutRefundRequestsInput;
  connect?: Prisma.SubscriptionWhereUniqueInput;
};

export type SubscriptionUpdateOneRequiredWithoutRefundRequestsNestedInput = {
  create?: Prisma.XOR<
    Prisma.SubscriptionCreateWithoutRefundRequestsInput,
    Prisma.SubscriptionUncheckedCreateWithoutRefundRequestsInput
  >;
  connectOrCreate?: Prisma.SubscriptionCreateOrConnectWithoutRefundRequestsInput;
  upsert?: Prisma.SubscriptionUpsertWithoutRefundRequestsInput;
  connect?: Prisma.SubscriptionWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.SubscriptionUpdateToOneWithWhereWithoutRefundRequestsInput,
      Prisma.SubscriptionUpdateWithoutRefundRequestsInput
    >,
    Prisma.SubscriptionUncheckedUpdateWithoutRefundRequestsInput
  >;
};

export type SubscriptionCreateNestedManyWithoutOverriddenByAdminInput = {
  create?:
    | Prisma.XOR<
        Prisma.SubscriptionCreateWithoutOverriddenByAdminInput,
        Prisma.SubscriptionUncheckedCreateWithoutOverriddenByAdminInput
      >
    | Prisma.SubscriptionCreateWithoutOverriddenByAdminInput[]
    | Prisma.SubscriptionUncheckedCreateWithoutOverriddenByAdminInput[];
  connectOrCreate?:
    | Prisma.SubscriptionCreateOrConnectWithoutOverriddenByAdminInput
    | Prisma.SubscriptionCreateOrConnectWithoutOverriddenByAdminInput[];
  createMany?: Prisma.SubscriptionCreateManyOverriddenByAdminInputEnvelope;
  connect?:
    | Prisma.SubscriptionWhereUniqueInput
    | Prisma.SubscriptionWhereUniqueInput[];
};

export type SubscriptionUncheckedCreateNestedManyWithoutOverriddenByAdminInput =
  {
    create?:
      | Prisma.XOR<
          Prisma.SubscriptionCreateWithoutOverriddenByAdminInput,
          Prisma.SubscriptionUncheckedCreateWithoutOverriddenByAdminInput
        >
      | Prisma.SubscriptionCreateWithoutOverriddenByAdminInput[]
      | Prisma.SubscriptionUncheckedCreateWithoutOverriddenByAdminInput[];
    connectOrCreate?:
      | Prisma.SubscriptionCreateOrConnectWithoutOverriddenByAdminInput
      | Prisma.SubscriptionCreateOrConnectWithoutOverriddenByAdminInput[];
    createMany?: Prisma.SubscriptionCreateManyOverriddenByAdminInputEnvelope;
    connect?:
      | Prisma.SubscriptionWhereUniqueInput
      | Prisma.SubscriptionWhereUniqueInput[];
  };

export type SubscriptionUpdateManyWithoutOverriddenByAdminNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.SubscriptionCreateWithoutOverriddenByAdminInput,
        Prisma.SubscriptionUncheckedCreateWithoutOverriddenByAdminInput
      >
    | Prisma.SubscriptionCreateWithoutOverriddenByAdminInput[]
    | Prisma.SubscriptionUncheckedCreateWithoutOverriddenByAdminInput[];
  connectOrCreate?:
    | Prisma.SubscriptionCreateOrConnectWithoutOverriddenByAdminInput
    | Prisma.SubscriptionCreateOrConnectWithoutOverriddenByAdminInput[];
  upsert?:
    | Prisma.SubscriptionUpsertWithWhereUniqueWithoutOverriddenByAdminInput
    | Prisma.SubscriptionUpsertWithWhereUniqueWithoutOverriddenByAdminInput[];
  createMany?: Prisma.SubscriptionCreateManyOverriddenByAdminInputEnvelope;
  set?:
    | Prisma.SubscriptionWhereUniqueInput
    | Prisma.SubscriptionWhereUniqueInput[];
  disconnect?:
    | Prisma.SubscriptionWhereUniqueInput
    | Prisma.SubscriptionWhereUniqueInput[];
  delete?:
    | Prisma.SubscriptionWhereUniqueInput
    | Prisma.SubscriptionWhereUniqueInput[];
  connect?:
    | Prisma.SubscriptionWhereUniqueInput
    | Prisma.SubscriptionWhereUniqueInput[];
  update?:
    | Prisma.SubscriptionUpdateWithWhereUniqueWithoutOverriddenByAdminInput
    | Prisma.SubscriptionUpdateWithWhereUniqueWithoutOverriddenByAdminInput[];
  updateMany?:
    | Prisma.SubscriptionUpdateManyWithWhereWithoutOverriddenByAdminInput
    | Prisma.SubscriptionUpdateManyWithWhereWithoutOverriddenByAdminInput[];
  deleteMany?:
    | Prisma.SubscriptionScalarWhereInput
    | Prisma.SubscriptionScalarWhereInput[];
};

export type SubscriptionUncheckedUpdateManyWithoutOverriddenByAdminNestedInput =
  {
    create?:
      | Prisma.XOR<
          Prisma.SubscriptionCreateWithoutOverriddenByAdminInput,
          Prisma.SubscriptionUncheckedCreateWithoutOverriddenByAdminInput
        >
      | Prisma.SubscriptionCreateWithoutOverriddenByAdminInput[]
      | Prisma.SubscriptionUncheckedCreateWithoutOverriddenByAdminInput[];
    connectOrCreate?:
      | Prisma.SubscriptionCreateOrConnectWithoutOverriddenByAdminInput
      | Prisma.SubscriptionCreateOrConnectWithoutOverriddenByAdminInput[];
    upsert?:
      | Prisma.SubscriptionUpsertWithWhereUniqueWithoutOverriddenByAdminInput
      | Prisma.SubscriptionUpsertWithWhereUniqueWithoutOverriddenByAdminInput[];
    createMany?: Prisma.SubscriptionCreateManyOverriddenByAdminInputEnvelope;
    set?:
      | Prisma.SubscriptionWhereUniqueInput
      | Prisma.SubscriptionWhereUniqueInput[];
    disconnect?:
      | Prisma.SubscriptionWhereUniqueInput
      | Prisma.SubscriptionWhereUniqueInput[];
    delete?:
      | Prisma.SubscriptionWhereUniqueInput
      | Prisma.SubscriptionWhereUniqueInput[];
    connect?:
      | Prisma.SubscriptionWhereUniqueInput
      | Prisma.SubscriptionWhereUniqueInput[];
    update?:
      | Prisma.SubscriptionUpdateWithWhereUniqueWithoutOverriddenByAdminInput
      | Prisma.SubscriptionUpdateWithWhereUniqueWithoutOverriddenByAdminInput[];
    updateMany?:
      | Prisma.SubscriptionUpdateManyWithWhereWithoutOverriddenByAdminInput
      | Prisma.SubscriptionUpdateManyWithWhereWithoutOverriddenByAdminInput[];
    deleteMany?:
      | Prisma.SubscriptionScalarWhereInput
      | Prisma.SubscriptionScalarWhereInput[];
  };

export type SubscriptionCreateWithoutStoreInput = {
  id?: string;
  tier?: $Enums.SubscriptionTier;
  status?: $Enums.SubscriptionStatus;
  isTrialUsed?: boolean;
  trialStartedAt?: Date | string | null;
  trialEndsAt?: Date | string | null;
  currentPeriodStart?: Date | string | null;
  currentPeriodEnd?: Date | string | null;
  billingCycle?: $Enums.BillingCycle;
  cancelledAt?: Date | string | null;
  cancellationReason?: string | null;
  overrideReason?: string | null;
  overriddenAt?: Date | string | null;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  paymentRequests?: Prisma.PaymentRequestCreateNestedManyWithoutSubscriptionInput;
  paymentTransactions?: Prisma.PaymentTransactionCreateNestedManyWithoutSubscriptionInput;
  refundRequests?: Prisma.RefundRequestCreateNestedManyWithoutSubscriptionInput;
  overriddenByAdmin?: Prisma.AdminUserCreateNestedOneWithoutOverriddenSubscriptionsInput;
};

export type SubscriptionUncheckedCreateWithoutStoreInput = {
  id?: string;
  tier?: $Enums.SubscriptionTier;
  status?: $Enums.SubscriptionStatus;
  isTrialUsed?: boolean;
  trialStartedAt?: Date | string | null;
  trialEndsAt?: Date | string | null;
  currentPeriodStart?: Date | string | null;
  currentPeriodEnd?: Date | string | null;
  billingCycle?: $Enums.BillingCycle;
  cancelledAt?: Date | string | null;
  cancellationReason?: string | null;
  overriddenBy?: string | null;
  overrideReason?: string | null;
  overriddenAt?: Date | string | null;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  paymentRequests?: Prisma.PaymentRequestUncheckedCreateNestedManyWithoutSubscriptionInput;
  paymentTransactions?: Prisma.PaymentTransactionUncheckedCreateNestedManyWithoutSubscriptionInput;
  refundRequests?: Prisma.RefundRequestUncheckedCreateNestedManyWithoutSubscriptionInput;
};

export type SubscriptionCreateOrConnectWithoutStoreInput = {
  where: Prisma.SubscriptionWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.SubscriptionCreateWithoutStoreInput,
    Prisma.SubscriptionUncheckedCreateWithoutStoreInput
  >;
};

export type SubscriptionUpsertWithoutStoreInput = {
  update: Prisma.XOR<
    Prisma.SubscriptionUpdateWithoutStoreInput,
    Prisma.SubscriptionUncheckedUpdateWithoutStoreInput
  >;
  create: Prisma.XOR<
    Prisma.SubscriptionCreateWithoutStoreInput,
    Prisma.SubscriptionUncheckedCreateWithoutStoreInput
  >;
  where?: Prisma.SubscriptionWhereInput;
};

export type SubscriptionUpdateToOneWithWhereWithoutStoreInput = {
  where?: Prisma.SubscriptionWhereInput;
  data: Prisma.XOR<
    Prisma.SubscriptionUpdateWithoutStoreInput,
    Prisma.SubscriptionUncheckedUpdateWithoutStoreInput
  >;
};

export type SubscriptionUpdateWithoutStoreInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  tier?:
    | Prisma.EnumSubscriptionTierFieldUpdateOperationsInput
    | $Enums.SubscriptionTier;
  status?:
    | Prisma.EnumSubscriptionStatusFieldUpdateOperationsInput
    | $Enums.SubscriptionStatus;
  isTrialUsed?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  trialStartedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  trialEndsAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodStart?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodEnd?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  billingCycle?:
    | Prisma.EnumBillingCycleFieldUpdateOperationsInput
    | $Enums.BillingCycle;
  cancelledAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  cancellationReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overrideReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overriddenAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  paymentRequests?: Prisma.PaymentRequestUpdateManyWithoutSubscriptionNestedInput;
  paymentTransactions?: Prisma.PaymentTransactionUpdateManyWithoutSubscriptionNestedInput;
  refundRequests?: Prisma.RefundRequestUpdateManyWithoutSubscriptionNestedInput;
  overriddenByAdmin?: Prisma.AdminUserUpdateOneWithoutOverriddenSubscriptionsNestedInput;
};

export type SubscriptionUncheckedUpdateWithoutStoreInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  tier?:
    | Prisma.EnumSubscriptionTierFieldUpdateOperationsInput
    | $Enums.SubscriptionTier;
  status?:
    | Prisma.EnumSubscriptionStatusFieldUpdateOperationsInput
    | $Enums.SubscriptionStatus;
  isTrialUsed?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  trialStartedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  trialEndsAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodStart?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodEnd?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  billingCycle?:
    | Prisma.EnumBillingCycleFieldUpdateOperationsInput
    | $Enums.BillingCycle;
  cancelledAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  cancellationReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overriddenBy?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overrideReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overriddenAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  paymentRequests?: Prisma.PaymentRequestUncheckedUpdateManyWithoutSubscriptionNestedInput;
  paymentTransactions?: Prisma.PaymentTransactionUncheckedUpdateManyWithoutSubscriptionNestedInput;
  refundRequests?: Prisma.RefundRequestUncheckedUpdateManyWithoutSubscriptionNestedInput;
};

export type SubscriptionCreateWithoutPaymentRequestsInput = {
  id?: string;
  tier?: $Enums.SubscriptionTier;
  status?: $Enums.SubscriptionStatus;
  isTrialUsed?: boolean;
  trialStartedAt?: Date | string | null;
  trialEndsAt?: Date | string | null;
  currentPeriodStart?: Date | string | null;
  currentPeriodEnd?: Date | string | null;
  billingCycle?: $Enums.BillingCycle;
  cancelledAt?: Date | string | null;
  cancellationReason?: string | null;
  overrideReason?: string | null;
  overriddenAt?: Date | string | null;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  store: Prisma.StoreCreateNestedOneWithoutSubscriptionInput;
  paymentTransactions?: Prisma.PaymentTransactionCreateNestedManyWithoutSubscriptionInput;
  refundRequests?: Prisma.RefundRequestCreateNestedManyWithoutSubscriptionInput;
  overriddenByAdmin?: Prisma.AdminUserCreateNestedOneWithoutOverriddenSubscriptionsInput;
};

export type SubscriptionUncheckedCreateWithoutPaymentRequestsInput = {
  id?: string;
  storeId: string;
  tier?: $Enums.SubscriptionTier;
  status?: $Enums.SubscriptionStatus;
  isTrialUsed?: boolean;
  trialStartedAt?: Date | string | null;
  trialEndsAt?: Date | string | null;
  currentPeriodStart?: Date | string | null;
  currentPeriodEnd?: Date | string | null;
  billingCycle?: $Enums.BillingCycle;
  cancelledAt?: Date | string | null;
  cancellationReason?: string | null;
  overriddenBy?: string | null;
  overrideReason?: string | null;
  overriddenAt?: Date | string | null;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  paymentTransactions?: Prisma.PaymentTransactionUncheckedCreateNestedManyWithoutSubscriptionInput;
  refundRequests?: Prisma.RefundRequestUncheckedCreateNestedManyWithoutSubscriptionInput;
};

export type SubscriptionCreateOrConnectWithoutPaymentRequestsInput = {
  where: Prisma.SubscriptionWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.SubscriptionCreateWithoutPaymentRequestsInput,
    Prisma.SubscriptionUncheckedCreateWithoutPaymentRequestsInput
  >;
};

export type SubscriptionUpsertWithoutPaymentRequestsInput = {
  update: Prisma.XOR<
    Prisma.SubscriptionUpdateWithoutPaymentRequestsInput,
    Prisma.SubscriptionUncheckedUpdateWithoutPaymentRequestsInput
  >;
  create: Prisma.XOR<
    Prisma.SubscriptionCreateWithoutPaymentRequestsInput,
    Prisma.SubscriptionUncheckedCreateWithoutPaymentRequestsInput
  >;
  where?: Prisma.SubscriptionWhereInput;
};

export type SubscriptionUpdateToOneWithWhereWithoutPaymentRequestsInput = {
  where?: Prisma.SubscriptionWhereInput;
  data: Prisma.XOR<
    Prisma.SubscriptionUpdateWithoutPaymentRequestsInput,
    Prisma.SubscriptionUncheckedUpdateWithoutPaymentRequestsInput
  >;
};

export type SubscriptionUpdateWithoutPaymentRequestsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  tier?:
    | Prisma.EnumSubscriptionTierFieldUpdateOperationsInput
    | $Enums.SubscriptionTier;
  status?:
    | Prisma.EnumSubscriptionStatusFieldUpdateOperationsInput
    | $Enums.SubscriptionStatus;
  isTrialUsed?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  trialStartedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  trialEndsAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodStart?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodEnd?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  billingCycle?:
    | Prisma.EnumBillingCycleFieldUpdateOperationsInput
    | $Enums.BillingCycle;
  cancelledAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  cancellationReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overrideReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overriddenAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  store?: Prisma.StoreUpdateOneRequiredWithoutSubscriptionNestedInput;
  paymentTransactions?: Prisma.PaymentTransactionUpdateManyWithoutSubscriptionNestedInput;
  refundRequests?: Prisma.RefundRequestUpdateManyWithoutSubscriptionNestedInput;
  overriddenByAdmin?: Prisma.AdminUserUpdateOneWithoutOverriddenSubscriptionsNestedInput;
};

export type SubscriptionUncheckedUpdateWithoutPaymentRequestsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  storeId?: Prisma.StringFieldUpdateOperationsInput | string;
  tier?:
    | Prisma.EnumSubscriptionTierFieldUpdateOperationsInput
    | $Enums.SubscriptionTier;
  status?:
    | Prisma.EnumSubscriptionStatusFieldUpdateOperationsInput
    | $Enums.SubscriptionStatus;
  isTrialUsed?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  trialStartedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  trialEndsAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodStart?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodEnd?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  billingCycle?:
    | Prisma.EnumBillingCycleFieldUpdateOperationsInput
    | $Enums.BillingCycle;
  cancelledAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  cancellationReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overriddenBy?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overrideReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overriddenAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  paymentTransactions?: Prisma.PaymentTransactionUncheckedUpdateManyWithoutSubscriptionNestedInput;
  refundRequests?: Prisma.RefundRequestUncheckedUpdateManyWithoutSubscriptionNestedInput;
};

export type SubscriptionCreateWithoutPaymentTransactionsInput = {
  id?: string;
  tier?: $Enums.SubscriptionTier;
  status?: $Enums.SubscriptionStatus;
  isTrialUsed?: boolean;
  trialStartedAt?: Date | string | null;
  trialEndsAt?: Date | string | null;
  currentPeriodStart?: Date | string | null;
  currentPeriodEnd?: Date | string | null;
  billingCycle?: $Enums.BillingCycle;
  cancelledAt?: Date | string | null;
  cancellationReason?: string | null;
  overrideReason?: string | null;
  overriddenAt?: Date | string | null;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  store: Prisma.StoreCreateNestedOneWithoutSubscriptionInput;
  paymentRequests?: Prisma.PaymentRequestCreateNestedManyWithoutSubscriptionInput;
  refundRequests?: Prisma.RefundRequestCreateNestedManyWithoutSubscriptionInput;
  overriddenByAdmin?: Prisma.AdminUserCreateNestedOneWithoutOverriddenSubscriptionsInput;
};

export type SubscriptionUncheckedCreateWithoutPaymentTransactionsInput = {
  id?: string;
  storeId: string;
  tier?: $Enums.SubscriptionTier;
  status?: $Enums.SubscriptionStatus;
  isTrialUsed?: boolean;
  trialStartedAt?: Date | string | null;
  trialEndsAt?: Date | string | null;
  currentPeriodStart?: Date | string | null;
  currentPeriodEnd?: Date | string | null;
  billingCycle?: $Enums.BillingCycle;
  cancelledAt?: Date | string | null;
  cancellationReason?: string | null;
  overriddenBy?: string | null;
  overrideReason?: string | null;
  overriddenAt?: Date | string | null;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  paymentRequests?: Prisma.PaymentRequestUncheckedCreateNestedManyWithoutSubscriptionInput;
  refundRequests?: Prisma.RefundRequestUncheckedCreateNestedManyWithoutSubscriptionInput;
};

export type SubscriptionCreateOrConnectWithoutPaymentTransactionsInput = {
  where: Prisma.SubscriptionWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.SubscriptionCreateWithoutPaymentTransactionsInput,
    Prisma.SubscriptionUncheckedCreateWithoutPaymentTransactionsInput
  >;
};

export type SubscriptionUpsertWithoutPaymentTransactionsInput = {
  update: Prisma.XOR<
    Prisma.SubscriptionUpdateWithoutPaymentTransactionsInput,
    Prisma.SubscriptionUncheckedUpdateWithoutPaymentTransactionsInput
  >;
  create: Prisma.XOR<
    Prisma.SubscriptionCreateWithoutPaymentTransactionsInput,
    Prisma.SubscriptionUncheckedCreateWithoutPaymentTransactionsInput
  >;
  where?: Prisma.SubscriptionWhereInput;
};

export type SubscriptionUpdateToOneWithWhereWithoutPaymentTransactionsInput = {
  where?: Prisma.SubscriptionWhereInput;
  data: Prisma.XOR<
    Prisma.SubscriptionUpdateWithoutPaymentTransactionsInput,
    Prisma.SubscriptionUncheckedUpdateWithoutPaymentTransactionsInput
  >;
};

export type SubscriptionUpdateWithoutPaymentTransactionsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  tier?:
    | Prisma.EnumSubscriptionTierFieldUpdateOperationsInput
    | $Enums.SubscriptionTier;
  status?:
    | Prisma.EnumSubscriptionStatusFieldUpdateOperationsInput
    | $Enums.SubscriptionStatus;
  isTrialUsed?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  trialStartedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  trialEndsAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodStart?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodEnd?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  billingCycle?:
    | Prisma.EnumBillingCycleFieldUpdateOperationsInput
    | $Enums.BillingCycle;
  cancelledAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  cancellationReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overrideReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overriddenAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  store?: Prisma.StoreUpdateOneRequiredWithoutSubscriptionNestedInput;
  paymentRequests?: Prisma.PaymentRequestUpdateManyWithoutSubscriptionNestedInput;
  refundRequests?: Prisma.RefundRequestUpdateManyWithoutSubscriptionNestedInput;
  overriddenByAdmin?: Prisma.AdminUserUpdateOneWithoutOverriddenSubscriptionsNestedInput;
};

export type SubscriptionUncheckedUpdateWithoutPaymentTransactionsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  storeId?: Prisma.StringFieldUpdateOperationsInput | string;
  tier?:
    | Prisma.EnumSubscriptionTierFieldUpdateOperationsInput
    | $Enums.SubscriptionTier;
  status?:
    | Prisma.EnumSubscriptionStatusFieldUpdateOperationsInput
    | $Enums.SubscriptionStatus;
  isTrialUsed?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  trialStartedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  trialEndsAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodStart?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodEnd?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  billingCycle?:
    | Prisma.EnumBillingCycleFieldUpdateOperationsInput
    | $Enums.BillingCycle;
  cancelledAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  cancellationReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overriddenBy?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overrideReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overriddenAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  paymentRequests?: Prisma.PaymentRequestUncheckedUpdateManyWithoutSubscriptionNestedInput;
  refundRequests?: Prisma.RefundRequestUncheckedUpdateManyWithoutSubscriptionNestedInput;
};

export type SubscriptionCreateWithoutRefundRequestsInput = {
  id?: string;
  tier?: $Enums.SubscriptionTier;
  status?: $Enums.SubscriptionStatus;
  isTrialUsed?: boolean;
  trialStartedAt?: Date | string | null;
  trialEndsAt?: Date | string | null;
  currentPeriodStart?: Date | string | null;
  currentPeriodEnd?: Date | string | null;
  billingCycle?: $Enums.BillingCycle;
  cancelledAt?: Date | string | null;
  cancellationReason?: string | null;
  overrideReason?: string | null;
  overriddenAt?: Date | string | null;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  store: Prisma.StoreCreateNestedOneWithoutSubscriptionInput;
  paymentRequests?: Prisma.PaymentRequestCreateNestedManyWithoutSubscriptionInput;
  paymentTransactions?: Prisma.PaymentTransactionCreateNestedManyWithoutSubscriptionInput;
  overriddenByAdmin?: Prisma.AdminUserCreateNestedOneWithoutOverriddenSubscriptionsInput;
};

export type SubscriptionUncheckedCreateWithoutRefundRequestsInput = {
  id?: string;
  storeId: string;
  tier?: $Enums.SubscriptionTier;
  status?: $Enums.SubscriptionStatus;
  isTrialUsed?: boolean;
  trialStartedAt?: Date | string | null;
  trialEndsAt?: Date | string | null;
  currentPeriodStart?: Date | string | null;
  currentPeriodEnd?: Date | string | null;
  billingCycle?: $Enums.BillingCycle;
  cancelledAt?: Date | string | null;
  cancellationReason?: string | null;
  overriddenBy?: string | null;
  overrideReason?: string | null;
  overriddenAt?: Date | string | null;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  paymentRequests?: Prisma.PaymentRequestUncheckedCreateNestedManyWithoutSubscriptionInput;
  paymentTransactions?: Prisma.PaymentTransactionUncheckedCreateNestedManyWithoutSubscriptionInput;
};

export type SubscriptionCreateOrConnectWithoutRefundRequestsInput = {
  where: Prisma.SubscriptionWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.SubscriptionCreateWithoutRefundRequestsInput,
    Prisma.SubscriptionUncheckedCreateWithoutRefundRequestsInput
  >;
};

export type SubscriptionUpsertWithoutRefundRequestsInput = {
  update: Prisma.XOR<
    Prisma.SubscriptionUpdateWithoutRefundRequestsInput,
    Prisma.SubscriptionUncheckedUpdateWithoutRefundRequestsInput
  >;
  create: Prisma.XOR<
    Prisma.SubscriptionCreateWithoutRefundRequestsInput,
    Prisma.SubscriptionUncheckedCreateWithoutRefundRequestsInput
  >;
  where?: Prisma.SubscriptionWhereInput;
};

export type SubscriptionUpdateToOneWithWhereWithoutRefundRequestsInput = {
  where?: Prisma.SubscriptionWhereInput;
  data: Prisma.XOR<
    Prisma.SubscriptionUpdateWithoutRefundRequestsInput,
    Prisma.SubscriptionUncheckedUpdateWithoutRefundRequestsInput
  >;
};

export type SubscriptionUpdateWithoutRefundRequestsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  tier?:
    | Prisma.EnumSubscriptionTierFieldUpdateOperationsInput
    | $Enums.SubscriptionTier;
  status?:
    | Prisma.EnumSubscriptionStatusFieldUpdateOperationsInput
    | $Enums.SubscriptionStatus;
  isTrialUsed?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  trialStartedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  trialEndsAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodStart?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodEnd?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  billingCycle?:
    | Prisma.EnumBillingCycleFieldUpdateOperationsInput
    | $Enums.BillingCycle;
  cancelledAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  cancellationReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overrideReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overriddenAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  store?: Prisma.StoreUpdateOneRequiredWithoutSubscriptionNestedInput;
  paymentRequests?: Prisma.PaymentRequestUpdateManyWithoutSubscriptionNestedInput;
  paymentTransactions?: Prisma.PaymentTransactionUpdateManyWithoutSubscriptionNestedInput;
  overriddenByAdmin?: Prisma.AdminUserUpdateOneWithoutOverriddenSubscriptionsNestedInput;
};

export type SubscriptionUncheckedUpdateWithoutRefundRequestsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  storeId?: Prisma.StringFieldUpdateOperationsInput | string;
  tier?:
    | Prisma.EnumSubscriptionTierFieldUpdateOperationsInput
    | $Enums.SubscriptionTier;
  status?:
    | Prisma.EnumSubscriptionStatusFieldUpdateOperationsInput
    | $Enums.SubscriptionStatus;
  isTrialUsed?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  trialStartedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  trialEndsAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodStart?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodEnd?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  billingCycle?:
    | Prisma.EnumBillingCycleFieldUpdateOperationsInput
    | $Enums.BillingCycle;
  cancelledAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  cancellationReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overriddenBy?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overrideReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overriddenAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  paymentRequests?: Prisma.PaymentRequestUncheckedUpdateManyWithoutSubscriptionNestedInput;
  paymentTransactions?: Prisma.PaymentTransactionUncheckedUpdateManyWithoutSubscriptionNestedInput;
};

export type SubscriptionCreateWithoutOverriddenByAdminInput = {
  id?: string;
  tier?: $Enums.SubscriptionTier;
  status?: $Enums.SubscriptionStatus;
  isTrialUsed?: boolean;
  trialStartedAt?: Date | string | null;
  trialEndsAt?: Date | string | null;
  currentPeriodStart?: Date | string | null;
  currentPeriodEnd?: Date | string | null;
  billingCycle?: $Enums.BillingCycle;
  cancelledAt?: Date | string | null;
  cancellationReason?: string | null;
  overrideReason?: string | null;
  overriddenAt?: Date | string | null;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  store: Prisma.StoreCreateNestedOneWithoutSubscriptionInput;
  paymentRequests?: Prisma.PaymentRequestCreateNestedManyWithoutSubscriptionInput;
  paymentTransactions?: Prisma.PaymentTransactionCreateNestedManyWithoutSubscriptionInput;
  refundRequests?: Prisma.RefundRequestCreateNestedManyWithoutSubscriptionInput;
};

export type SubscriptionUncheckedCreateWithoutOverriddenByAdminInput = {
  id?: string;
  storeId: string;
  tier?: $Enums.SubscriptionTier;
  status?: $Enums.SubscriptionStatus;
  isTrialUsed?: boolean;
  trialStartedAt?: Date | string | null;
  trialEndsAt?: Date | string | null;
  currentPeriodStart?: Date | string | null;
  currentPeriodEnd?: Date | string | null;
  billingCycle?: $Enums.BillingCycle;
  cancelledAt?: Date | string | null;
  cancellationReason?: string | null;
  overrideReason?: string | null;
  overriddenAt?: Date | string | null;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  paymentRequests?: Prisma.PaymentRequestUncheckedCreateNestedManyWithoutSubscriptionInput;
  paymentTransactions?: Prisma.PaymentTransactionUncheckedCreateNestedManyWithoutSubscriptionInput;
  refundRequests?: Prisma.RefundRequestUncheckedCreateNestedManyWithoutSubscriptionInput;
};

export type SubscriptionCreateOrConnectWithoutOverriddenByAdminInput = {
  where: Prisma.SubscriptionWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.SubscriptionCreateWithoutOverriddenByAdminInput,
    Prisma.SubscriptionUncheckedCreateWithoutOverriddenByAdminInput
  >;
};

export type SubscriptionCreateManyOverriddenByAdminInputEnvelope = {
  data:
    | Prisma.SubscriptionCreateManyOverriddenByAdminInput
    | Prisma.SubscriptionCreateManyOverriddenByAdminInput[];
  skipDuplicates?: boolean;
};

export type SubscriptionUpsertWithWhereUniqueWithoutOverriddenByAdminInput = {
  where: Prisma.SubscriptionWhereUniqueInput;
  update: Prisma.XOR<
    Prisma.SubscriptionUpdateWithoutOverriddenByAdminInput,
    Prisma.SubscriptionUncheckedUpdateWithoutOverriddenByAdminInput
  >;
  create: Prisma.XOR<
    Prisma.SubscriptionCreateWithoutOverriddenByAdminInput,
    Prisma.SubscriptionUncheckedCreateWithoutOverriddenByAdminInput
  >;
};

export type SubscriptionUpdateWithWhereUniqueWithoutOverriddenByAdminInput = {
  where: Prisma.SubscriptionWhereUniqueInput;
  data: Prisma.XOR<
    Prisma.SubscriptionUpdateWithoutOverriddenByAdminInput,
    Prisma.SubscriptionUncheckedUpdateWithoutOverriddenByAdminInput
  >;
};

export type SubscriptionUpdateManyWithWhereWithoutOverriddenByAdminInput = {
  where: Prisma.SubscriptionScalarWhereInput;
  data: Prisma.XOR<
    Prisma.SubscriptionUpdateManyMutationInput,
    Prisma.SubscriptionUncheckedUpdateManyWithoutOverriddenByAdminInput
  >;
};

export type SubscriptionScalarWhereInput = {
  AND?:
    | Prisma.SubscriptionScalarWhereInput
    | Prisma.SubscriptionScalarWhereInput[];
  OR?: Prisma.SubscriptionScalarWhereInput[];
  NOT?:
    | Prisma.SubscriptionScalarWhereInput
    | Prisma.SubscriptionScalarWhereInput[];
  id?: Prisma.StringFilter<'Subscription'> | string;
  storeId?: Prisma.StringFilter<'Subscription'> | string;
  tier?:
    | Prisma.EnumSubscriptionTierFilter<'Subscription'>
    | $Enums.SubscriptionTier;
  status?:
    | Prisma.EnumSubscriptionStatusFilter<'Subscription'>
    | $Enums.SubscriptionStatus;
  isTrialUsed?: Prisma.BoolFilter<'Subscription'> | boolean;
  trialStartedAt?:
    | Prisma.DateTimeNullableFilter<'Subscription'>
    | Date
    | string
    | null;
  trialEndsAt?:
    | Prisma.DateTimeNullableFilter<'Subscription'>
    | Date
    | string
    | null;
  currentPeriodStart?:
    | Prisma.DateTimeNullableFilter<'Subscription'>
    | Date
    | string
    | null;
  currentPeriodEnd?:
    | Prisma.DateTimeNullableFilter<'Subscription'>
    | Date
    | string
    | null;
  billingCycle?:
    | Prisma.EnumBillingCycleFilter<'Subscription'>
    | $Enums.BillingCycle;
  cancelledAt?:
    | Prisma.DateTimeNullableFilter<'Subscription'>
    | Date
    | string
    | null;
  cancellationReason?:
    | Prisma.StringNullableFilter<'Subscription'>
    | string
    | null;
  overriddenBy?: Prisma.StringNullableFilter<'Subscription'> | string | null;
  overrideReason?: Prisma.StringNullableFilter<'Subscription'> | string | null;
  overriddenAt?:
    | Prisma.DateTimeNullableFilter<'Subscription'>
    | Date
    | string
    | null;
  createdAt?: Prisma.DateTimeFilter<'Subscription'> | Date | string;
  updatedAt?: Prisma.DateTimeFilter<'Subscription'> | Date | string;
};

export type SubscriptionCreateManyOverriddenByAdminInput = {
  id?: string;
  storeId: string;
  tier?: $Enums.SubscriptionTier;
  status?: $Enums.SubscriptionStatus;
  isTrialUsed?: boolean;
  trialStartedAt?: Date | string | null;
  trialEndsAt?: Date | string | null;
  currentPeriodStart?: Date | string | null;
  currentPeriodEnd?: Date | string | null;
  billingCycle?: $Enums.BillingCycle;
  cancelledAt?: Date | string | null;
  cancellationReason?: string | null;
  overrideReason?: string | null;
  overriddenAt?: Date | string | null;
  createdAt?: Date | string;
  updatedAt?: Date | string;
};

export type SubscriptionUpdateWithoutOverriddenByAdminInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  tier?:
    | Prisma.EnumSubscriptionTierFieldUpdateOperationsInput
    | $Enums.SubscriptionTier;
  status?:
    | Prisma.EnumSubscriptionStatusFieldUpdateOperationsInput
    | $Enums.SubscriptionStatus;
  isTrialUsed?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  trialStartedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  trialEndsAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodStart?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodEnd?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  billingCycle?:
    | Prisma.EnumBillingCycleFieldUpdateOperationsInput
    | $Enums.BillingCycle;
  cancelledAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  cancellationReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overrideReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overriddenAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  store?: Prisma.StoreUpdateOneRequiredWithoutSubscriptionNestedInput;
  paymentRequests?: Prisma.PaymentRequestUpdateManyWithoutSubscriptionNestedInput;
  paymentTransactions?: Prisma.PaymentTransactionUpdateManyWithoutSubscriptionNestedInput;
  refundRequests?: Prisma.RefundRequestUpdateManyWithoutSubscriptionNestedInput;
};

export type SubscriptionUncheckedUpdateWithoutOverriddenByAdminInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  storeId?: Prisma.StringFieldUpdateOperationsInput | string;
  tier?:
    | Prisma.EnumSubscriptionTierFieldUpdateOperationsInput
    | $Enums.SubscriptionTier;
  status?:
    | Prisma.EnumSubscriptionStatusFieldUpdateOperationsInput
    | $Enums.SubscriptionStatus;
  isTrialUsed?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  trialStartedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  trialEndsAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodStart?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodEnd?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  billingCycle?:
    | Prisma.EnumBillingCycleFieldUpdateOperationsInput
    | $Enums.BillingCycle;
  cancelledAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  cancellationReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overrideReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overriddenAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  paymentRequests?: Prisma.PaymentRequestUncheckedUpdateManyWithoutSubscriptionNestedInput;
  paymentTransactions?: Prisma.PaymentTransactionUncheckedUpdateManyWithoutSubscriptionNestedInput;
  refundRequests?: Prisma.RefundRequestUncheckedUpdateManyWithoutSubscriptionNestedInput;
};

export type SubscriptionUncheckedUpdateManyWithoutOverriddenByAdminInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  storeId?: Prisma.StringFieldUpdateOperationsInput | string;
  tier?:
    | Prisma.EnumSubscriptionTierFieldUpdateOperationsInput
    | $Enums.SubscriptionTier;
  status?:
    | Prisma.EnumSubscriptionStatusFieldUpdateOperationsInput
    | $Enums.SubscriptionStatus;
  isTrialUsed?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  trialStartedAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  trialEndsAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodStart?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  currentPeriodEnd?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  billingCycle?:
    | Prisma.EnumBillingCycleFieldUpdateOperationsInput
    | $Enums.BillingCycle;
  cancelledAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  cancellationReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overrideReason?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  overriddenAt?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

/**
 * Count Type SubscriptionCountOutputType
 */

export type SubscriptionCountOutputType = {
  paymentRequests: number;
  paymentTransactions: number;
  refundRequests: number;
};

export type SubscriptionCountOutputTypeSelect<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  paymentRequests?:
    | boolean
    | SubscriptionCountOutputTypeCountPaymentRequestsArgs;
  paymentTransactions?:
    | boolean
    | SubscriptionCountOutputTypeCountPaymentTransactionsArgs;
  refundRequests?: boolean | SubscriptionCountOutputTypeCountRefundRequestsArgs;
};

/**
 * SubscriptionCountOutputType without action
 */
export type SubscriptionCountOutputTypeDefaultArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the SubscriptionCountOutputType
   */
  select?: Prisma.SubscriptionCountOutputTypeSelect<ExtArgs> | null;
};

/**
 * SubscriptionCountOutputType without action
 */
export type SubscriptionCountOutputTypeCountPaymentRequestsArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.PaymentRequestWhereInput;
};

/**
 * SubscriptionCountOutputType without action
 */
export type SubscriptionCountOutputTypeCountPaymentTransactionsArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.PaymentTransactionWhereInput;
};

/**
 * SubscriptionCountOutputType without action
 */
export type SubscriptionCountOutputTypeCountRefundRequestsArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.RefundRequestWhereInput;
};

export type SubscriptionSelect<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    storeId?: boolean;
    tier?: boolean;
    status?: boolean;
    isTrialUsed?: boolean;
    trialStartedAt?: boolean;
    trialEndsAt?: boolean;
    currentPeriodStart?: boolean;
    currentPeriodEnd?: boolean;
    billingCycle?: boolean;
    cancelledAt?: boolean;
    cancellationReason?: boolean;
    overriddenBy?: boolean;
    overrideReason?: boolean;
    overriddenAt?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    store?: boolean | Prisma.StoreDefaultArgs<ExtArgs>;
    paymentRequests?:
      | boolean
      | Prisma.Subscription$paymentRequestsArgs<ExtArgs>;
    paymentTransactions?:
      | boolean
      | Prisma.Subscription$paymentTransactionsArgs<ExtArgs>;
    refundRequests?: boolean | Prisma.Subscription$refundRequestsArgs<ExtArgs>;
    overriddenByAdmin?:
      | boolean
      | Prisma.Subscription$overriddenByAdminArgs<ExtArgs>;
    _count?: boolean | Prisma.SubscriptionCountOutputTypeDefaultArgs<ExtArgs>;
  },
  ExtArgs['result']['subscription']
>;

export type SubscriptionSelectCreateManyAndReturn<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    storeId?: boolean;
    tier?: boolean;
    status?: boolean;
    isTrialUsed?: boolean;
    trialStartedAt?: boolean;
    trialEndsAt?: boolean;
    currentPeriodStart?: boolean;
    currentPeriodEnd?: boolean;
    billingCycle?: boolean;
    cancelledAt?: boolean;
    cancellationReason?: boolean;
    overriddenBy?: boolean;
    overrideReason?: boolean;
    overriddenAt?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    store?: boolean | Prisma.StoreDefaultArgs<ExtArgs>;
    overriddenByAdmin?:
      | boolean
      | Prisma.Subscription$overriddenByAdminArgs<ExtArgs>;
  },
  ExtArgs['result']['subscription']
>;

export type SubscriptionSelectUpdateManyAndReturn<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    storeId?: boolean;
    tier?: boolean;
    status?: boolean;
    isTrialUsed?: boolean;
    trialStartedAt?: boolean;
    trialEndsAt?: boolean;
    currentPeriodStart?: boolean;
    currentPeriodEnd?: boolean;
    billingCycle?: boolean;
    cancelledAt?: boolean;
    cancellationReason?: boolean;
    overriddenBy?: boolean;
    overrideReason?: boolean;
    overriddenAt?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    store?: boolean | Prisma.StoreDefaultArgs<ExtArgs>;
    overriddenByAdmin?:
      | boolean
      | Prisma.Subscription$overriddenByAdminArgs<ExtArgs>;
  },
  ExtArgs['result']['subscription']
>;

export type SubscriptionSelectScalar = {
  id?: boolean;
  storeId?: boolean;
  tier?: boolean;
  status?: boolean;
  isTrialUsed?: boolean;
  trialStartedAt?: boolean;
  trialEndsAt?: boolean;
  currentPeriodStart?: boolean;
  currentPeriodEnd?: boolean;
  billingCycle?: boolean;
  cancelledAt?: boolean;
  cancellationReason?: boolean;
  overriddenBy?: boolean;
  overrideReason?: boolean;
  overriddenAt?: boolean;
  createdAt?: boolean;
  updatedAt?: boolean;
};

export type SubscriptionOmit<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetOmit<
  | 'id'
  | 'storeId'
  | 'tier'
  | 'status'
  | 'isTrialUsed'
  | 'trialStartedAt'
  | 'trialEndsAt'
  | 'currentPeriodStart'
  | 'currentPeriodEnd'
  | 'billingCycle'
  | 'cancelledAt'
  | 'cancellationReason'
  | 'overriddenBy'
  | 'overrideReason'
  | 'overriddenAt'
  | 'createdAt'
  | 'updatedAt',
  ExtArgs['result']['subscription']
>;
export type SubscriptionInclude<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  store?: boolean | Prisma.StoreDefaultArgs<ExtArgs>;
  paymentRequests?: boolean | Prisma.Subscription$paymentRequestsArgs<ExtArgs>;
  paymentTransactions?:
    | boolean
    | Prisma.Subscription$paymentTransactionsArgs<ExtArgs>;
  refundRequests?: boolean | Prisma.Subscription$refundRequestsArgs<ExtArgs>;
  overriddenByAdmin?:
    | boolean
    | Prisma.Subscription$overriddenByAdminArgs<ExtArgs>;
  _count?: boolean | Prisma.SubscriptionCountOutputTypeDefaultArgs<ExtArgs>;
};
export type SubscriptionIncludeCreateManyAndReturn<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  store?: boolean | Prisma.StoreDefaultArgs<ExtArgs>;
  overriddenByAdmin?:
    | boolean
    | Prisma.Subscription$overriddenByAdminArgs<ExtArgs>;
};
export type SubscriptionIncludeUpdateManyAndReturn<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  store?: boolean | Prisma.StoreDefaultArgs<ExtArgs>;
  overriddenByAdmin?:
    | boolean
    | Prisma.Subscription$overriddenByAdminArgs<ExtArgs>;
};

export type $SubscriptionPayload<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  name: 'Subscription';
  objects: {
    store: Prisma.$StorePayload<ExtArgs>;
    paymentRequests: Prisma.$PaymentRequestPayload<ExtArgs>[];
    paymentTransactions: Prisma.$PaymentTransactionPayload<ExtArgs>[];
    refundRequests: Prisma.$RefundRequestPayload<ExtArgs>[];
    overriddenByAdmin: Prisma.$AdminUserPayload<ExtArgs> | null;
  };
  scalars: runtime.Types.Extensions.GetPayloadResult<
    {
      id: string;
      storeId: string;
      tier: $Enums.SubscriptionTier;
      status: $Enums.SubscriptionStatus;
      isTrialUsed: boolean;
      trialStartedAt: Date | null;
      trialEndsAt: Date | null;
      currentPeriodStart: Date | null;
      currentPeriodEnd: Date | null;
      billingCycle: $Enums.BillingCycle;
      cancelledAt: Date | null;
      cancellationReason: string | null;
      overriddenBy: string | null;
      overrideReason: string | null;
      overriddenAt: Date | null;
      createdAt: Date;
      updatedAt: Date;
    },
    ExtArgs['result']['subscription']
  >;
  composites: {};
};

export type SubscriptionGetPayload<
  S extends boolean | null | undefined | SubscriptionDefaultArgs,
> = runtime.Types.Result.GetResult<Prisma.$SubscriptionPayload, S>;

export type SubscriptionCountArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = Omit<
  SubscriptionFindManyArgs,
  'select' | 'include' | 'distinct' | 'omit'
> & {
  select?: SubscriptionCountAggregateInputType | true;
};

export interface SubscriptionDelegate<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
  GlobalOmitOptions = {},
> {
  [K: symbol]: {
    types: Prisma.TypeMap<ExtArgs>['model']['Subscription'];
    meta: { name: 'Subscription' };
  };
  /**
   * Find zero or one Subscription that matches the filter.
   * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
   * @example
   * // Get one Subscription
   * const subscription = await prisma.subscription.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends SubscriptionFindUniqueArgs>(
    args: Prisma.SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>
  ): Prisma.Prisma__SubscriptionClient<
    runtime.Types.Result.GetResult<
      Prisma.$SubscriptionPayload<ExtArgs>,
      T,
      'findUnique',
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
   * @example
   * // Get one Subscription
   * const subscription = await prisma.subscription.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(
    args: Prisma.SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>
  ): Prisma.Prisma__SubscriptionClient<
    runtime.Types.Result.GetResult<
      Prisma.$SubscriptionPayload<ExtArgs>,
      T,
      'findUniqueOrThrow',
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find the first Subscription that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
   * @example
   * // Get one Subscription
   * const subscription = await prisma.subscription.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends SubscriptionFindFirstArgs>(
    args?: Prisma.SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>
  ): Prisma.Prisma__SubscriptionClient<
    runtime.Types.Result.GetResult<
      Prisma.$SubscriptionPayload<ExtArgs>,
      T,
      'findFirst',
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find the first Subscription that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
   * @example
   * // Get one Subscription
   * const subscription = await prisma.subscription.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(
    args?: Prisma.SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>
  ): Prisma.Prisma__SubscriptionClient<
    runtime.Types.Result.GetResult<
      Prisma.$SubscriptionPayload<ExtArgs>,
      T,
      'findFirstOrThrow',
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find zero or more Subscriptions that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Subscriptions
   * const subscriptions = await prisma.subscription.findMany()
   *
   * // Get first 10 Subscriptions
   * const subscriptions = await prisma.subscription.findMany({ take: 10 })
   *
   * // Only select the `id`
   * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
   *
   */
  findMany<T extends SubscriptionFindManyArgs>(
    args?: Prisma.SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$SubscriptionPayload<ExtArgs>,
      T,
      'findMany',
      GlobalOmitOptions
    >
  >;

  /**
   * Create a Subscription.
   * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
   * @example
   * // Create one Subscription
   * const Subscription = await prisma.subscription.create({
   *   data: {
   *     // ... data to create a Subscription
   *   }
   * })
   *
   */
  create<T extends SubscriptionCreateArgs>(
    args: Prisma.SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>
  ): Prisma.Prisma__SubscriptionClient<
    runtime.Types.Result.GetResult<
      Prisma.$SubscriptionPayload<ExtArgs>,
      T,
      'create',
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Create many Subscriptions.
   * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
   * @example
   * // Create many Subscriptions
   * const subscription = await prisma.subscription.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   */
  createMany<T extends SubscriptionCreateManyArgs>(
    args?: Prisma.SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Create many Subscriptions and returns the data saved in the database.
   * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
   * @example
   * // Create many Subscriptions
   * const subscription = await prisma.subscription.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   * // Create many Subscriptions and only return the `id`
   * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   *
   */
  createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(
    args?: Prisma.SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$SubscriptionPayload<ExtArgs>,
      T,
      'createManyAndReturn',
      GlobalOmitOptions
    >
  >;

  /**
   * Delete a Subscription.
   * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
   * @example
   * // Delete one Subscription
   * const Subscription = await prisma.subscription.delete({
   *   where: {
   *     // ... filter to delete one Subscription
   *   }
   * })
   *
   */
  delete<T extends SubscriptionDeleteArgs>(
    args: Prisma.SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>
  ): Prisma.Prisma__SubscriptionClient<
    runtime.Types.Result.GetResult<
      Prisma.$SubscriptionPayload<ExtArgs>,
      T,
      'delete',
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Update one Subscription.
   * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
   * @example
   * // Update one Subscription
   * const subscription = await prisma.subscription.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   *
   */
  update<T extends SubscriptionUpdateArgs>(
    args: Prisma.SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>
  ): Prisma.Prisma__SubscriptionClient<
    runtime.Types.Result.GetResult<
      Prisma.$SubscriptionPayload<ExtArgs>,
      T,
      'update',
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Delete zero or more Subscriptions.
   * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
   * @example
   * // Delete a few Subscriptions
   * const { count } = await prisma.subscription.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   *
   */
  deleteMany<T extends SubscriptionDeleteManyArgs>(
    args?: Prisma.SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Update zero or more Subscriptions.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Subscriptions
   * const subscription = await prisma.subscription.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   *
   */
  updateMany<T extends SubscriptionUpdateManyArgs>(
    args: Prisma.SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Update zero or more Subscriptions and returns the data updated in the database.
   * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
   * @example
   * // Update many Subscriptions
   * const subscription = await prisma.subscription.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   * // Update zero or more Subscriptions and only return the `id`
   * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   *
   */
  updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(
    args: Prisma.SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$SubscriptionPayload<ExtArgs>,
      T,
      'updateManyAndReturn',
      GlobalOmitOptions
    >
  >;

  /**
   * Create or update one Subscription.
   * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
   * @example
   * // Update or create a Subscription
   * const subscription = await prisma.subscription.upsert({
   *   create: {
   *     // ... data to create a Subscription
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Subscription we want to update
   *   }
   * })
   */
  upsert<T extends SubscriptionUpsertArgs>(
    args: Prisma.SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>
  ): Prisma.Prisma__SubscriptionClient<
    runtime.Types.Result.GetResult<
      Prisma.$SubscriptionPayload<ExtArgs>,
      T,
      'upsert',
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Count the number of Subscriptions.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
   * @example
   * // Count the number of Subscriptions
   * const count = await prisma.subscription.count({
   *   where: {
   *     // ... the filter for the Subscriptions we want to count
   *   }
   * })
   **/
  count<T extends SubscriptionCountArgs>(
    args?: Prisma.Subset<T, SubscriptionCountArgs>
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<
            T['select'],
            SubscriptionCountAggregateOutputType
          >
      : number
  >;

  /**
   * Allows you to perform aggregations operations on a Subscription.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
   **/
  aggregate<T extends SubscriptionAggregateArgs>(
    args: Prisma.Subset<T, SubscriptionAggregateArgs>
  ): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>;

  /**
   * Group by Subscription.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {SubscriptionGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   *
   **/
  groupBy<
    T extends SubscriptionGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
      : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<
      Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>
    >,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
      ? `Error: "by" must not be empty.`
      : HavingValid extends Prisma.False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
                ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                : [
                    Error,
                    'Field ',
                    P,
                    ` in "having" needs to be provided in "by"`,
                  ];
          }[HavingFields]
        : 'take' extends Prisma.Keys<T>
          ? 'orderBy' extends Prisma.Keys<T>
            ? ByValid extends Prisma.True
              ? {}
              : {
                  [P in OrderFields]: P extends ByFields
                    ? never
                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                }[OrderFields]
            : 'Error: If you provide "take", you also need to provide "orderBy"'
          : 'skip' extends Prisma.Keys<T>
            ? 'orderBy' extends Prisma.Keys<T>
              ? ByValid extends Prisma.True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "skip", you also need to provide "orderBy"'
            : ByValid extends Prisma.True
              ? {}
              : {
                  [P in OrderFields]: P extends ByFields
                    ? never
                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                }[OrderFields],
  >(
    args: Prisma.SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> &
      InputErrors
  ): {} extends InputErrors
    ? GetSubscriptionGroupByPayload<T>
    : Prisma.PrismaPromise<InputErrors>;
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Subscription.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__SubscriptionClient<
  T,
  Null = never,
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
  GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: 'PrismaPromise';
  store<T extends Prisma.StoreDefaultArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.StoreDefaultArgs<ExtArgs>>
  ): Prisma.Prisma__StoreClient<
    | runtime.Types.Result.GetResult<
        Prisma.$StorePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >
    | Null,
    Null,
    ExtArgs,
    GlobalOmitOptions
  >;
  paymentRequests<
    T extends Prisma.Subscription$paymentRequestsArgs<ExtArgs> = {},
  >(
    args?: Prisma.Subset<T, Prisma.Subscription$paymentRequestsArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$PaymentRequestPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    | Null
  >;
  paymentTransactions<
    T extends Prisma.Subscription$paymentTransactionsArgs<ExtArgs> = {},
  >(
    args?: Prisma.Subset<
      T,
      Prisma.Subscription$paymentTransactionsArgs<ExtArgs>
    >
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$PaymentTransactionPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    | Null
  >;
  refundRequests<
    T extends Prisma.Subscription$refundRequestsArgs<ExtArgs> = {},
  >(
    args?: Prisma.Subset<T, Prisma.Subscription$refundRequestsArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$RefundRequestPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    | Null
  >;
  overriddenByAdmin<
    T extends Prisma.Subscription$overriddenByAdminArgs<ExtArgs> = {},
  >(
    args?: Prisma.Subset<T, Prisma.Subscription$overriddenByAdminArgs<ExtArgs>>
  ): Prisma.Prisma__AdminUserClient<
    runtime.Types.Result.GetResult<
      Prisma.$AdminUserPayload<ExtArgs>,
      T,
      'findUniqueOrThrow',
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(
    onfulfilled?:
      | ((value: T) => TResult1 | PromiseLike<TResult1>)
      | undefined
      | null,
    onrejected?:
      | ((reason: any) => TResult2 | PromiseLike<TResult2>)
      | undefined
      | null
  ): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(
    onrejected?:
      | ((reason: any) => TResult | PromiseLike<TResult>)
      | undefined
      | null
  ): runtime.Types.Utils.JsPromise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(
    onfinally?: (() => void) | undefined | null
  ): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the Subscription model
 */
export interface SubscriptionFieldRefs {
  readonly id: Prisma.FieldRef<'Subscription', 'String'>;
  readonly storeId: Prisma.FieldRef<'Subscription', 'String'>;
  readonly tier: Prisma.FieldRef<'Subscription', 'SubscriptionTier'>;
  readonly status: Prisma.FieldRef<'Subscription', 'SubscriptionStatus'>;
  readonly isTrialUsed: Prisma.FieldRef<'Subscription', 'Boolean'>;
  readonly trialStartedAt: Prisma.FieldRef<'Subscription', 'DateTime'>;
  readonly trialEndsAt: Prisma.FieldRef<'Subscription', 'DateTime'>;
  readonly currentPeriodStart: Prisma.FieldRef<'Subscription', 'DateTime'>;
  readonly currentPeriodEnd: Prisma.FieldRef<'Subscription', 'DateTime'>;
  readonly billingCycle: Prisma.FieldRef<'Subscription', 'BillingCycle'>;
  readonly cancelledAt: Prisma.FieldRef<'Subscription', 'DateTime'>;
  readonly cancellationReason: Prisma.FieldRef<'Subscription', 'String'>;
  readonly overriddenBy: Prisma.FieldRef<'Subscription', 'String'>;
  readonly overrideReason: Prisma.FieldRef<'Subscription', 'String'>;
  readonly overriddenAt: Prisma.FieldRef<'Subscription', 'DateTime'>;
  readonly createdAt: Prisma.FieldRef<'Subscription', 'DateTime'>;
  readonly updatedAt: Prisma.FieldRef<'Subscription', 'DateTime'>;
}

// Custom InputTypes
/**
 * Subscription findUnique
 */
export type SubscriptionFindUniqueArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Subscription
   */
  select?: Prisma.SubscriptionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Subscription
   */
  omit?: Prisma.SubscriptionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SubscriptionInclude<ExtArgs> | null;
  /**
   * Filter, which Subscription to fetch.
   */
  where: Prisma.SubscriptionWhereUniqueInput;
};

/**
 * Subscription findUniqueOrThrow
 */
export type SubscriptionFindUniqueOrThrowArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Subscription
   */
  select?: Prisma.SubscriptionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Subscription
   */
  omit?: Prisma.SubscriptionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SubscriptionInclude<ExtArgs> | null;
  /**
   * Filter, which Subscription to fetch.
   */
  where: Prisma.SubscriptionWhereUniqueInput;
};

/**
 * Subscription findFirst
 */
export type SubscriptionFindFirstArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Subscription
   */
  select?: Prisma.SubscriptionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Subscription
   */
  omit?: Prisma.SubscriptionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SubscriptionInclude<ExtArgs> | null;
  /**
   * Filter, which Subscription to fetch.
   */
  where?: Prisma.SubscriptionWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of Subscriptions to fetch.
   */
  orderBy?:
    | Prisma.SubscriptionOrderByWithRelationInput
    | Prisma.SubscriptionOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for searching for Subscriptions.
   */
  cursor?: Prisma.SubscriptionWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` Subscriptions from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` Subscriptions.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   *
   * Filter by unique combinations of Subscriptions.
   */
  distinct?:
    | Prisma.SubscriptionScalarFieldEnum
    | Prisma.SubscriptionScalarFieldEnum[];
};

/**
 * Subscription findFirstOrThrow
 */
export type SubscriptionFindFirstOrThrowArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Subscription
   */
  select?: Prisma.SubscriptionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Subscription
   */
  omit?: Prisma.SubscriptionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SubscriptionInclude<ExtArgs> | null;
  /**
   * Filter, which Subscription to fetch.
   */
  where?: Prisma.SubscriptionWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of Subscriptions to fetch.
   */
  orderBy?:
    | Prisma.SubscriptionOrderByWithRelationInput
    | Prisma.SubscriptionOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for searching for Subscriptions.
   */
  cursor?: Prisma.SubscriptionWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` Subscriptions from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` Subscriptions.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   *
   * Filter by unique combinations of Subscriptions.
   */
  distinct?:
    | Prisma.SubscriptionScalarFieldEnum
    | Prisma.SubscriptionScalarFieldEnum[];
};

/**
 * Subscription findMany
 */
export type SubscriptionFindManyArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Subscription
   */
  select?: Prisma.SubscriptionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Subscription
   */
  omit?: Prisma.SubscriptionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SubscriptionInclude<ExtArgs> | null;
  /**
   * Filter, which Subscriptions to fetch.
   */
  where?: Prisma.SubscriptionWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of Subscriptions to fetch.
   */
  orderBy?:
    | Prisma.SubscriptionOrderByWithRelationInput
    | Prisma.SubscriptionOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for listing Subscriptions.
   */
  cursor?: Prisma.SubscriptionWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` Subscriptions from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` Subscriptions.
   */
  skip?: number;
  distinct?:
    | Prisma.SubscriptionScalarFieldEnum
    | Prisma.SubscriptionScalarFieldEnum[];
};

/**
 * Subscription create
 */
export type SubscriptionCreateArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Subscription
   */
  select?: Prisma.SubscriptionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Subscription
   */
  omit?: Prisma.SubscriptionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SubscriptionInclude<ExtArgs> | null;
  /**
   * The data needed to create a Subscription.
   */
  data: Prisma.XOR<
    Prisma.SubscriptionCreateInput,
    Prisma.SubscriptionUncheckedCreateInput
  >;
};

/**
 * Subscription createMany
 */
export type SubscriptionCreateManyArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * The data used to create many Subscriptions.
   */
  data:
    | Prisma.SubscriptionCreateManyInput
    | Prisma.SubscriptionCreateManyInput[];
  skipDuplicates?: boolean;
};

/**
 * Subscription createManyAndReturn
 */
export type SubscriptionCreateManyAndReturnArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Subscription
   */
  select?: Prisma.SubscriptionSelectCreateManyAndReturn<ExtArgs> | null;
  /**
   * Omit specific fields from the Subscription
   */
  omit?: Prisma.SubscriptionOmit<ExtArgs> | null;
  /**
   * The data used to create many Subscriptions.
   */
  data:
    | Prisma.SubscriptionCreateManyInput
    | Prisma.SubscriptionCreateManyInput[];
  skipDuplicates?: boolean;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null;
};

/**
 * Subscription update
 */
export type SubscriptionUpdateArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Subscription
   */
  select?: Prisma.SubscriptionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Subscription
   */
  omit?: Prisma.SubscriptionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SubscriptionInclude<ExtArgs> | null;
  /**
   * The data needed to update a Subscription.
   */
  data: Prisma.XOR<
    Prisma.SubscriptionUpdateInput,
    Prisma.SubscriptionUncheckedUpdateInput
  >;
  /**
   * Choose, which Subscription to update.
   */
  where: Prisma.SubscriptionWhereUniqueInput;
};

/**
 * Subscription updateMany
 */
export type SubscriptionUpdateManyArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * The data used to update Subscriptions.
   */
  data: Prisma.XOR<
    Prisma.SubscriptionUpdateManyMutationInput,
    Prisma.SubscriptionUncheckedUpdateManyInput
  >;
  /**
   * Filter which Subscriptions to update
   */
  where?: Prisma.SubscriptionWhereInput;
  /**
   * Limit how many Subscriptions to update.
   */
  limit?: number;
};

/**
 * Subscription updateManyAndReturn
 */
export type SubscriptionUpdateManyAndReturnArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Subscription
   */
  select?: Prisma.SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null;
  /**
   * Omit specific fields from the Subscription
   */
  omit?: Prisma.SubscriptionOmit<ExtArgs> | null;
  /**
   * The data used to update Subscriptions.
   */
  data: Prisma.XOR<
    Prisma.SubscriptionUpdateManyMutationInput,
    Prisma.SubscriptionUncheckedUpdateManyInput
  >;
  /**
   * Filter which Subscriptions to update
   */
  where?: Prisma.SubscriptionWhereInput;
  /**
   * Limit how many Subscriptions to update.
   */
  limit?: number;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null;
};

/**
 * Subscription upsert
 */
export type SubscriptionUpsertArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Subscription
   */
  select?: Prisma.SubscriptionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Subscription
   */
  omit?: Prisma.SubscriptionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SubscriptionInclude<ExtArgs> | null;
  /**
   * The filter to search for the Subscription to update in case it exists.
   */
  where: Prisma.SubscriptionWhereUniqueInput;
  /**
   * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
   */
  create: Prisma.XOR<
    Prisma.SubscriptionCreateInput,
    Prisma.SubscriptionUncheckedCreateInput
  >;
  /**
   * In case the Subscription was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<
    Prisma.SubscriptionUpdateInput,
    Prisma.SubscriptionUncheckedUpdateInput
  >;
};

/**
 * Subscription delete
 */
export type SubscriptionDeleteArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Subscription
   */
  select?: Prisma.SubscriptionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Subscription
   */
  omit?: Prisma.SubscriptionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SubscriptionInclude<ExtArgs> | null;
  /**
   * Filter which Subscription to delete.
   */
  where: Prisma.SubscriptionWhereUniqueInput;
};

/**
 * Subscription deleteMany
 */
export type SubscriptionDeleteManyArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Filter which Subscriptions to delete
   */
  where?: Prisma.SubscriptionWhereInput;
  /**
   * Limit how many Subscriptions to delete.
   */
  limit?: number;
};

/**
 * Subscription.paymentRequests
 */
export type Subscription$paymentRequestsArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the PaymentRequest
   */
  select?: Prisma.PaymentRequestSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the PaymentRequest
   */
  omit?: Prisma.PaymentRequestOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PaymentRequestInclude<ExtArgs> | null;
  where?: Prisma.PaymentRequestWhereInput;
  orderBy?:
    | Prisma.PaymentRequestOrderByWithRelationInput
    | Prisma.PaymentRequestOrderByWithRelationInput[];
  cursor?: Prisma.PaymentRequestWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?:
    | Prisma.PaymentRequestScalarFieldEnum
    | Prisma.PaymentRequestScalarFieldEnum[];
};

/**
 * Subscription.paymentTransactions
 */
export type Subscription$paymentTransactionsArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the PaymentTransaction
   */
  select?: Prisma.PaymentTransactionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the PaymentTransaction
   */
  omit?: Prisma.PaymentTransactionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PaymentTransactionInclude<ExtArgs> | null;
  where?: Prisma.PaymentTransactionWhereInput;
  orderBy?:
    | Prisma.PaymentTransactionOrderByWithRelationInput
    | Prisma.PaymentTransactionOrderByWithRelationInput[];
  cursor?: Prisma.PaymentTransactionWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?:
    | Prisma.PaymentTransactionScalarFieldEnum
    | Prisma.PaymentTransactionScalarFieldEnum[];
};

/**
 * Subscription.refundRequests
 */
export type Subscription$refundRequestsArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the RefundRequest
   */
  select?: Prisma.RefundRequestSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the RefundRequest
   */
  omit?: Prisma.RefundRequestOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RefundRequestInclude<ExtArgs> | null;
  where?: Prisma.RefundRequestWhereInput;
  orderBy?:
    | Prisma.RefundRequestOrderByWithRelationInput
    | Prisma.RefundRequestOrderByWithRelationInput[];
  cursor?: Prisma.RefundRequestWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?:
    | Prisma.RefundRequestScalarFieldEnum
    | Prisma.RefundRequestScalarFieldEnum[];
};

/**
 * Subscription.overriddenByAdmin
 */
export type Subscription$overriddenByAdminArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the AdminUser
   */
  select?: Prisma.AdminUserSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the AdminUser
   */
  omit?: Prisma.AdminUserOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AdminUserInclude<ExtArgs> | null;
  where?: Prisma.AdminUserWhereInput;
};

/**
 * Subscription without action
 */
export type SubscriptionDefaultArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Subscription
   */
  select?: Prisma.SubscriptionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Subscription
   */
  omit?: Prisma.SubscriptionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SubscriptionInclude<ExtArgs> | null;
};
