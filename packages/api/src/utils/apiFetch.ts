/**
 * API Fetch Utilities
 *
 * This module provides error classes and response helpers for API operations.
 * The main API client is now provided by openapi-fetch in the client module.
 */

import type { ErrorDetail, StandardApiResponse } from '../types/api.types';

// Re-export types for convenience
export type { StandardApiResponse } from '../types/api.types';

/**
 * Represents the wrapped API response structure from openapi-fetch.
 * The backend wraps all responses in StandardApiResponse, so the actual
 * payload is nested under `data.data`.
 *
 * @example
 * ```typescript
 * // API returns: { status: 'success', data: CartResponseDto, message: '...' }
 * // openapi-fetch gives: { data: { status, data, message }, error, response }
 * // So actual payload is at: data.data
 * ```
 */
export interface WrappedApiResponse<T> {
  status?: 'success' | 'error';
  data?: T;
  message?: string | null;
  errors?: ErrorDetail[] | null;
}

// Error classes for API operations
export class FetchError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'FetchError';
  }
}

export class NetworkError extends FetchError {
  constructor(message: string) {
    super(message);
    this.name = 'NetworkError';
  }
}

export class ApiError extends FetchError {
  public status: number;
  public errors: ErrorDetail[] | null;
  public responseJson: StandardApiResponse<unknown> | null;

  constructor(
    message: string,
    status: number,
    responseJson: StandardApiResponse<unknown> | null = null
  ) {
    super(message);
    this.name = 'ApiError';
    this.status = status;
    this.responseJson = responseJson;
    this.errors = responseJson?.errors ?? null;
  }
}

export class UnauthorizedError extends ApiError {
  constructor(
    message: string = 'Unauthorized',
    responseJson: StandardApiResponse<unknown> | null = null
  ) {
    super(message, 401, responseJson);
    this.name = 'UnauthorizedError';
  }
}

/**
 * Helper function to unwrap API response data with consistent null checking.
 * Throws an error if data is null.
 *
 * @param response - The API response object (can be from openapi-fetch or legacy format)
 * @param errorMessage - Custom error message if data is null
 * @returns The unwrapped data
 *
 * @example
 * ```typescript
 * // With openapi-fetch
 * const { data, error } = await client.GET('/stores/{storeId}/categories', { ... });
 * if (error) throw new ApiError(error.message, error.status);
 * return unwrapData({ data }, 'Failed to retrieve categories');
 *
 * // With legacy StandardApiResponse
 * const res = await apiFetch<Category[]>('/categories');
 * return unwrapData(res, 'Failed to retrieve categories');
 * ```
 */
export function unwrapData<T>(
  response: { data: T | null | undefined } | StandardApiResponse<T>,
  errorMessage: string
): T {
  // Handle both new format { data } and old format StandardApiResponse
  const data = 'status' in response ? response.data : response.data;

  if (data == null) {
    throw new Error(errorMessage);
  }
  return data;
}

/**
 * Helper type to extract the inner data type from a wrapped API response.
 * Handles the intersection type `StandardApiResponse & { data?: T }` generated by OpenAPI.
 */
export type ExtractDataType<T> = T extends { data?: infer D } ? D : never;

/**
 * Extracts the inner data payload from a wrapped API response.
 *
 * The backend wraps all responses in StandardApiResponse format:
 * `{ status: 'success' | 'error', data: T, message: string, errors: [] }`
 *
 * When using openapi-fetch, the response structure is:
 * `{ data: WrappedApiResponse<T>, error, response }`
 *
 * This function extracts `T` from the nested `data.data` without requiring
 * type assertions in service code.
 *
 * @param wrappedResponse - The wrapped response from openapi-fetch (the `data` property)
 * @param errorMessage - Error message to throw if data extraction fails
 * @param status - HTTP status code for error reporting
 * @returns The unwrapped data payload of type T
 * @throws {ApiError} If the response indicates an error or data is null/undefined
 *
 * @example
 * ```typescript
 * const { data, error, response } = await apiClient.GET('/cart', {
 *   params: { query: { sessionId } },
 * });
 *
 * if (error) {
 *   throw new ApiError('Failed to fetch cart', response.status);
 * }
 *
 * // data is WrappedApiResponse<CartResponseDto>
 * // Returns CartResponseDto without type assertion!
 * return extractData(data, 'Failed to fetch cart', response.status);
 * ```
 */
export function extractData<T>(
  wrappedResponse: WrappedApiResponse<T> | null | undefined,
  errorMessage: string,
  status: number = 500
): T {
  if (!wrappedResponse) {
    throw new ApiError(errorMessage, status);
  }

  // Check if the API response indicates an error
  if (wrappedResponse.status === 'error') {
    throw new ApiError(
      wrappedResponse.message ?? errorMessage,
      status,
      wrappedResponse as unknown as StandardApiResponse<unknown>
    );
  }

  // Extract the nested data
  const data = wrappedResponse.data;

  if (data === null || data === undefined) {
    throw new ApiError(
      wrappedResponse.message ?? errorMessage,
      status,
      wrappedResponse as unknown as StandardApiResponse<unknown>
    );
  }

  return data;
}

/**
 * Type-safe helper to process openapi-fetch response and extract the payload.
 *
 * This is the recommended way to handle API responses in service files.
 * It handles error checking and data extraction in one call.
 *
 * @param result - The full result from openapi-fetch { data, error, response }
 * @param errorMessage - Error message to throw on failure
 * @returns The unwrapped data payload of type T
 * @throws {ApiError} If there's an error or data is missing
 *
 * @example
 * ```typescript
 * export async function getCart(sessionId: string): Promise<CartResponseDto> {
 *   const result = await apiClient.GET('/cart', {
 *     params: { query: { sessionId } },
 *   });
 *
 *   // Returns CartResponseDto - no type assertion needed!
 *   return handleApiResponse(result, 'Failed to fetch cart');
 * }
 * ```
 */
export function handleApiResponse<T>(
  result: {
    data?: WrappedApiResponse<T>;
    error?: unknown;
    response: Response;
  },
  errorMessage: string
): T {
  const { data, error, response } = result;

  if (error) {
    throw new ApiError(errorMessage, response.status);
  }

  return extractData(data, errorMessage, response.status);
}

/**
 * Type-safe helper to extract data from openapi-fetch response with proper type inference.
 *
 * This function is designed to work with the generated OpenAPI types where responses
 * are typed as `StandardApiResponse & { data?: SomeDto }`. It properly extracts the
 * inner `data` property with the correct type.
 *
 * @param result - The full result from openapi-fetch { data, error, response }
 * @param errorMessage - Error message to throw on failure
 * @returns The unwrapped data payload with correctly inferred type
 * @throws {ApiError} If there's an error or data is missing
 *
 * @example
 * ```typescript
 * export async function getCart(sessionId: string): Promise<CartResponseDto> {
 *   const result = await apiClient.GET('/cart', {
 *     params: { query: { sessionId } },
 *   });
 *
 *   // TypeScript infers the return type from the OpenAPI types!
 *   return unwrapApiResponse(result, 'Failed to fetch cart');
 * }
 * ```
 */
export function unwrapApiResponse<
  TResponse extends { data?: unknown; status?: string; message?: string | null },
>(
  result: {
    data?: TResponse;
    error?: unknown;
    response: Response;
  },
  errorMessage: string
): ExtractDataType<TResponse> {
  const { data, error, response } = result;

  if (error) {
    throw new ApiError(errorMessage, response.status);
  }

  if (!data) {
    throw new ApiError(errorMessage, response.status);
  }

  // Check if the API response indicates an error
  if (data.status === 'error') {
    throw new ApiError(
      (data.message as string) ?? errorMessage,
      response.status
    );
  }

  // Extract the nested data
  const innerData = data.data;

  if (innerData === null || innerData === undefined) {
    throw new ApiError(
      (data.message as string) ?? errorMessage,
      response.status
    );
  }

  return innerData as ExtractDataType<TResponse>;
}

/**
 * Type guard to check if an error is an ApiError
 */
export function isApiError(error: unknown): error is ApiError {
  return error instanceof ApiError;
}

/**
 * Type guard to check if an error is an UnauthorizedError
 */
export function isUnauthorizedError(
  error: unknown
): error is UnauthorizedError {
  return error instanceof UnauthorizedError;
}

/**
 * Type guard to check if an error is a NetworkError
 */
export function isNetworkError(error: unknown): error is NetworkError {
  return error instanceof NetworkError;
}
